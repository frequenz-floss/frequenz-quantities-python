{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frequenz Quantities Library","text":"<p>Types for holding quantities with units.</p> <p>This library provide types for holding quantities with units. The main goal is to avoid mistakes while working with different types of quantities, for example avoiding adding a length to a time.</p> <p>It also prevents mistakes when operating between the same quantity but in different units, like adding a power in Joules to a power in Watts without converting one of them.</p> <p>Quantities store the value in a base unit, and then provide methods to get that quantity as a particular unit. They can only be constructed using special constructors with the form <code>Quantity.from_&lt;unit&gt;</code>, for example <code>Power.from_watts(10.0)</code>.</p> <p>Internally quantities store values as <code>float</code>s, so regular float issues and limitations apply, although some of them are tried to be mitigated.</p> <p>Quantities are also immutable, so operations between quantities return a new instance of the quantity.</p> <p>This library provides the following types:</p> <ul> <li>Current: A quantity representing an electric current.</li> <li>Energy: A quantity representing energy.</li> <li>Frequency: A quantity representing frequency.</li> <li>Percentage: A quantity representing a percentage.</li> <li>Power: A quantity representing power.</li> <li>Temperature: A quantity representing temperature.</li> <li>Voltage: A quantity representing electric voltage.</li> </ul> <p>There is also the unitless Quantity class. All quantities are subclasses of this class and it can be used as a base to create new quantities. Using the <code>Quantity</code> class directly is discouraged, as it doesn't provide any unit conversion methods.</p> Example <pre><code>from datetime import timedelta\nfrom frequenz.quantities import Power, Voltage, Current, Energy\n\n# Create a power quantity\npower = Power.from_watts(230.0)\n\n# Printing uses a unit to make the string as short as possible\nprint(f\"Power: {power}\")  # Power: 230.0 W\n# The precision can be changed\nprint(f\"Power: {power:0.3}\")  # Power: 230.000 W\n# The conversion methods can be used to get the value in a particular unit\nprint(f\"Power in MW: {power.as_megawatt()}\")  # Power in MW: 0.00023 MW\n\n# Create a voltage quantity\nvoltage = Voltage.from_volts(230.0)\n\n# Calculate the current\ncurrent = power / voltage\nassert isinstance(current, Current)\nprint(f\"Current: {current}\")  # Current: 1.0 A\nassert current.isclose(Current.from_amperes(1.0))\n\n# Calculate the energy\nenergy = power * timedelta(hours=1)\nassert isinstance(energy, Energy)\nprint(f\"Energy: {energy}\")  # Energy: 230.0 Wh\nprint(f\"Energy in kWh: {energy.as_kilowatt_hours()}\") # Energy in kWh: 0.23\n\n# Invalid operations are not permitted\n# (when using a type hinting linter like mypy, this will be caught at linting time)\ntry:\n    power + voltage\nexcept TypeError as e:\n    print(f\"Error: {e}\")  # Error: unsupported operand type(s) for +: 'Power' and 'Voltage'\n</code></pre>"},{"location":"CONTRIBUTING/","title":"Contributing to Frequenz Quantities Library","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"CONTRIBUTING/#cross-arch-testing","title":"Cross-Arch Testing","text":"<p>This project has built-in support for testing across multiple architectures. Currently, our CI conducts tests on <code>arm64</code> machines using QEMU emulation. We also have the flexibility to expand this support to include additional architectures in the future.</p> <p>This project contains Dockerfiles that can be used in the CI to test the python package in non-native machine architectures, e.g., <code>arm64</code>. The Dockerfiles exist in the directory <code>.github/containers/nox-cross-arch</code>, and follow a naming scheme so that they can be easily used in build matrices in the CI, in <code>nox-cross-arch</code> job. The naming scheme is:</p> <pre><code>&lt;arch&gt;-&lt;os&gt;-python-&lt;python-version&gt;.Dockerfile\n</code></pre> <p>E.g.,</p> <pre><code>arm64-ubuntu-20.04-python-3.11.Dockerfile\n</code></pre> <p>If a Dockerfile for your desired target architecture, OS, and python version does not exist here, please add one before proceeding to add your options to the test matrix.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>quantities</li> </ul> </li> </ul>"},{"location":"reference/frequenz/quantities/","title":"quantities","text":""},{"location":"reference/frequenz/quantities/#frequenz.quantities","title":"frequenz.quantities","text":"<p>Types for holding quantities with units.</p> <p>This library provide types for holding quantities with units. The main goal is to avoid mistakes while working with different types of quantities, for example avoiding adding a length to a time.</p> <p>It also prevents mistakes when operating between the same quantity but in different units, like adding a power in Joules to a power in Watts without converting one of them.</p> <p>Quantities store the value in a base unit, and then provide methods to get that quantity as a particular unit. They can only be constructed using special constructors with the form <code>Quantity.from_&lt;unit&gt;</code>, for example <code>Power.from_watts(10.0)</code>.</p> <p>Internally quantities store values as <code>float</code>s, so regular float issues and limitations apply, although some of them are tried to be mitigated.</p> <p>Quantities are also immutable, so operations between quantities return a new instance of the quantity.</p> <p>This library provides the following types:</p> <ul> <li>Current: A quantity representing an electric current.</li> <li>Energy: A quantity representing energy.</li> <li>Frequency: A quantity representing frequency.</li> <li>Percentage: A quantity representing a percentage.</li> <li>Power: A quantity representing power.</li> <li>Temperature: A quantity representing temperature.</li> <li>Voltage: A quantity representing electric voltage.</li> </ul> <p>There is also the unitless Quantity class. All quantities are subclasses of this class and it can be used as a base to create new quantities. Using the <code>Quantity</code> class directly is discouraged, as it doesn't provide any unit conversion methods.</p> Example <pre><code>from datetime import timedelta\nfrom frequenz.quantities import Power, Voltage, Current, Energy\n\n# Create a power quantity\npower = Power.from_watts(230.0)\n\n# Printing uses a unit to make the string as short as possible\nprint(f\"Power: {power}\")  # Power: 230.0 W\n# The precision can be changed\nprint(f\"Power: {power:0.3}\")  # Power: 230.000 W\n# The conversion methods can be used to get the value in a particular unit\nprint(f\"Power in MW: {power.as_megawatt()}\")  # Power in MW: 0.00023 MW\n\n# Create a voltage quantity\nvoltage = Voltage.from_volts(230.0)\n\n# Calculate the current\ncurrent = power / voltage\nassert isinstance(current, Current)\nprint(f\"Current: {current}\")  # Current: 1.0 A\nassert current.isclose(Current.from_amperes(1.0))\n\n# Calculate the energy\nenergy = power * timedelta(hours=1)\nassert isinstance(energy, Energy)\nprint(f\"Energy: {energy}\")  # Energy: 230.0 Wh\nprint(f\"Energy in kWh: {energy.as_kilowatt_hours()}\") # Energy in kWh: 0.23\n\n# Invalid operations are not permitted\n# (when using a type hinting linter like mypy, this will be caught at linting time)\ntry:\n    power + voltage\nexcept TypeError as e:\n    print(f\"Error: {e}\")  # Error: unsupported operand type(s) for +: 'Power' and 'Voltage'\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities-classes","title":"Classes","text":""},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current","title":"frequenz.quantities.Current","text":"<p>               Bases: <code>Quantity</code></p> <p>A current quantity.</p> <p>Objects of this type are wrappers around <code>float</code> values and are immutable.</p> <p>The constructors accept a single <code>float</code> value, the <code>as_*()</code> methods return a <code>float</code> value, and each of the arithmetic operators supported by this type are actually implemented using floating-point arithmetic.</p> <p>So all considerations about floating-point arithmetic apply to this type as well.</p> Source code in <code>frequenz/quantities/_current.py</code> <pre><code>class Current(\n    Quantity,\n    metaclass=NoDefaultConstructible,\n    exponent_unit_map={\n        -3: \"mA\",\n        0: \"A\",\n    },\n):\n    \"\"\"A current quantity.\n\n    Objects of this type are wrappers around `float` values and are immutable.\n\n    The constructors accept a single `float` value, the `as_*()` methods return a\n    `float` value, and each of the arithmetic operators supported by this type are\n    actually implemented using floating-point arithmetic.\n\n    So all considerations about floating-point arithmetic apply to this type as well.\n    \"\"\"\n\n    @classmethod\n    def from_amperes(cls, amperes: float) -&gt; Self:\n        \"\"\"Initialize a new current quantity.\n\n        Args:\n            amperes: The current in amperes.\n\n        Returns:\n            A new current quantity.\n        \"\"\"\n        return cls._new(amperes)\n\n    @classmethod\n    def from_milliamperes(cls, milliamperes: float) -&gt; Self:\n        \"\"\"Initialize a new current quantity.\n\n        Args:\n            milliamperes: The current in milliamperes.\n\n        Returns:\n            A new current quantity.\n        \"\"\"\n        return cls._new(milliamperes, exponent=-3)\n\n    def as_amperes(self) -&gt; float:\n        \"\"\"Return the current in amperes.\n\n        Returns:\n            The current in amperes.\n        \"\"\"\n        return self._base_value\n\n    def as_milliamperes(self) -&gt; float:\n        \"\"\"Return the current in milliamperes.\n\n        Returns:\n            The current in milliamperes.\n        \"\"\"\n        return self._base_value * 1e3\n\n    # See comment for Power.__mul__ for why we need the ignore here.\n    @overload  # type: ignore[override]\n    def __mul__(self, scalar: float, /) -&gt; Self:\n        \"\"\"Scale this current by a scalar.\n\n        Args:\n            scalar: The scalar by which to scale this current.\n\n        Returns:\n            The scaled current.\n        \"\"\"\n\n    @overload\n    def __mul__(self, percent: Percentage, /) -&gt; Self:\n        \"\"\"Scale this current by a percentage.\n\n        Args:\n            percent: The percentage by which to scale this current.\n\n        Returns:\n            The scaled current.\n        \"\"\"\n\n    @overload\n    def __mul__(self, other: Voltage, /) -&gt; Power:\n        \"\"\"Multiply the current by a voltage to get a power.\n\n        Args:\n            other: The voltage.\n\n        Returns:\n            The calculated power.\n        \"\"\"\n\n    def __mul__(self, other: float | Percentage | Voltage, /) -&gt; Self | Power:\n        \"\"\"Return a current or power from multiplying this current by the given value.\n\n        Args:\n            other: The scalar, percentage or voltage to multiply by.\n\n        Returns:\n            A current or power.\n        \"\"\"\n        from ._percentage import Percentage  # pylint: disable=import-outside-toplevel\n        from ._power import Power  # pylint: disable=import-outside-toplevel\n        from ._voltage import Voltage  # pylint: disable=import-outside-toplevel\n\n        match other:\n            case float() | Percentage():\n                return super().__mul__(other)\n            case Voltage():\n                return Power._new(self._base_value * other._base_value)\n            case _:\n                return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current.base_unit","title":"base_unit  <code>property</code>","text":"<pre><code>base_unit: str | None\n</code></pre> <p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current.base_value","title":"base_value  <code>property</code>","text":"<pre><code>base_value: float\n</code></pre> <p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current-functions","title":"Functions","text":""},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> <p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __abs__(self) -&gt; Self:\n    \"\"\"Return the absolute value of this quantity.\n\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\n    absolute = type(self).__new__(type(self))\n    absolute._base_value = abs(self._base_value)\n    return absolute\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current.__add__","title":"__add__","text":"<pre><code>__add__(other: Self) -&gt; Self\n</code></pre> <p>Return the sum of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n    \"\"\"Return the sum of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    summe = type(self).__new__(type(self))\n    summe._base_value = self._base_value + other._base_value\n    return summe\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether this quantity is equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Return whether this quantity is equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    # The above check ensures that both quantities are the exact same type, because\n    # `isinstance` returns true for subclasses and superclasses.  But the above check\n    # doesn't help mypy identify the type of other,  so the below line is necessary.\n    assert isinstance(other, self.__class__)\n    return self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current.__format__","title":"__format__","text":"<pre><code>__format__(__format_spec: str) -&gt; str\n</code></pre> <p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.quantities import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n    \"\"\"Return a formatted string representation of this quantity.\n\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n\n    Example:\n        ```python\n        from frequenz.quantities import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n\n    Args:\n        __format_spec: The format specifier.\n\n    Returns:\n        A string representation of this quantity.\n\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\n    keep_trailing_zeros = False\n    if __format_spec != \"\":\n        fspec_parts = __format_spec.split(\".\")\n        if (\n            len(fspec_parts) != 2\n            or fspec_parts[0] not in (\"\", \"0\")\n            or not fspec_parts[1].isdigit()\n        ):\n            raise ValueError(\n                \"Invalid format specifier. Must be empty or `[0].{precision}`\"\n            )\n        if fspec_parts[0] == \"0\":\n            keep_trailing_zeros = True\n        precision = int(fspec_parts[1])\n    else:\n        precision = 3\n    if not self._exponent_unit_map:\n        return f\"{self._base_value:.{precision}f}\"\n\n    if math.isinf(self._base_value) or math.isnan(self._base_value):\n        return f\"{self._base_value} {self._exponent_unit_map[0]}\"\n\n    if abs_value := abs(self._base_value):\n        precision_pow = 10 ** (precision)\n        # Prevent numbers like 999.999999 being rendered as 1000 V\n        # instead of 1 kV.\n        # This could happen because the str formatting function does\n        # rounding as well.\n        # This is an imperfect solution that works for _most_ cases.\n        # isclose parameters were chosen according to the observed cases\n        if math.isclose(abs_value, precision_pow, abs_tol=1e-4, rel_tol=0.01):\n            # If the value is close to the precision, round it\n            exponent = math.ceil(math.log10(precision_pow))\n        else:\n            exponent = math.floor(math.log10(abs_value))\n    else:\n        exponent = 0\n\n    unit_place = exponent - exponent % 3\n    if unit_place &lt; min(self._exponent_unit_map):\n        unit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\n        unit_place = min(self._exponent_unit_map)\n    elif unit_place &gt; max(self._exponent_unit_map):\n        unit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\n        unit_place = max(self._exponent_unit_map)\n    else:\n        unit = self._exponent_unit_map[unit_place]\n\n    value_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\n\n    if value_str in (\"-0\", \"0\"):\n        stripped = value_str\n    else:\n        stripped = value_str.rstrip(\"0\").rstrip(\".\")\n\n    if not keep_trailing_zeros:\n        value_str = stripped\n    unit_str = unit if stripped not in (\"-0\", \"0\") else self._exponent_unit_map[0]\n    return f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than or equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current.__init__","title":"__init__","text":"<pre><code>__init__(value: float, exponent: int = 0) -&gt; None\n</code></pre> <p>Initialize a new quantity.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n    \"\"\"Initialize a new quantity.\n\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\n    self._base_value = value * 10.0**exponent\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(\n    exponent_unit_map: dict[int, str]\n) -&gt; None\n</code></pre> <p>Initialize a new subclass of Quantity.</p> PARAMETER DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n    \"\"\"Initialize a new subclass of Quantity.\n\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n\n    Raises:\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\n    if 0 not in exponent_unit_map:\n        raise ValueError(\"Expected a base unit for the type (for exponent 0)\")\n    cls._exponent_unit_map = exponent_unit_map\n    super().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current.__le__","title":"__le__","text":"<pre><code>__le__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than or equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current.__mod__","title":"__mod__","text":"<pre><code>__mod__(other: Self) -&gt; Self\n</code></pre> <p>Return the remainder of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The remainder of this quantity and another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __mod__(self, other: Self) -&gt; Self:\n    \"\"\"Return the remainder of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The remainder of this quantity and another.\n    \"\"\"\n    return self._new(self._base_value % other._base_value)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current.__mul__","title":"__mul__","text":"<pre><code>__mul__(\n    other: float | Percentage | Voltage,\n) -&gt; Self | Power\n</code></pre> <p>Return a current or power from multiplying this current by the given value.</p> PARAMETER DESCRIPTION <code>other</code> <p>The scalar, percentage or voltage to multiply by.</p> <p> TYPE: <code>float | Percentage | Voltage</code> </p> RETURNS DESCRIPTION <code>Self | Power</code> <p>A current or power.</p> Source code in <code>frequenz/quantities/_current.py</code> <pre><code>def __mul__(self, other: float | Percentage | Voltage, /) -&gt; Self | Power:\n    \"\"\"Return a current or power from multiplying this current by the given value.\n\n    Args:\n        other: The scalar, percentage or voltage to multiply by.\n\n    Returns:\n        A current or power.\n    \"\"\"\n    from ._percentage import Percentage  # pylint: disable=import-outside-toplevel\n    from ._power import Power  # pylint: disable=import-outside-toplevel\n    from ._voltage import Voltage  # pylint: disable=import-outside-toplevel\n\n    match other:\n        case float() | Percentage():\n            return super().__mul__(other)\n        case Voltage():\n            return Power._new(self._base_value * other._base_value)\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> <p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __neg__(self) -&gt; Self:\n    \"\"\"Return the negation of this quantity.\n\n    Returns:\n        The negation of this quantity.\n    \"\"\"\n    negation = type(self).__new__(type(self))\n    negation._base_value = -self._base_value\n    return negation\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current.__pos__","title":"__pos__","text":"<pre><code>__pos__() -&gt; Self\n</code></pre> <p>Return this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>This quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __pos__(self) -&gt; Self:\n    \"\"\"Return this quantity.\n\n    Returns:\n        This quantity.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a representation of this quantity.\n\n    Returns:\n        A representation of this quantity.\n    \"\"\"\n    return f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current.__round__","title":"__round__","text":"<pre><code>__round__(ndigits: int | None = None) -&gt; Self\n</code></pre> <p>Round this quantity to the given number of digits.</p> PARAMETER DESCRIPTION <code>ndigits</code> <p>The number of digits to round to.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The rounded quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __round__(self, ndigits: int | None = None) -&gt; Self:\n    \"\"\"Round this quantity to the given number of digits.\n\n    Args:\n        ndigits: The number of digits to round to.\n\n    Returns:\n        The rounded quantity.\n    \"\"\"\n    return self._new(round(self._base_value, ndigits))\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this quantity.\n\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\n    return self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Self) -&gt; Self\n</code></pre> <p>Return the difference of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n    \"\"\"Return the difference of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    difference = type(self).__new__(type(self))\n    difference._base_value = self._base_value - other._base_value\n    return difference\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(value: float | Self) -&gt; Self | float\n</code></pre> <p>Divide this quantity by a scalar or another quantity.</p> PARAMETER DESCRIPTION <code>value</code> <p>The scalar or quantity to divide this quantity by.</p> <p> TYPE: <code>float | Self</code> </p> RETURNS DESCRIPTION <code>Self | float</code> <p>The divided quantity or the ratio of this quantity to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __truediv__(self, value: float | Self, /) -&gt; Self | float:\n    \"\"\"Divide this quantity by a scalar or another quantity.\n\n    Args:\n        value: The scalar or quantity to divide this quantity by.\n\n    Returns:\n        The divided quantity or the ratio of this quantity to another.\n    \"\"\"\n    match value:\n        case float():\n            return type(self)._new(self._base_value / value)\n        case Quantity() if type(value) is type(self):\n            return self._base_value / value._base_value\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current.as_amperes","title":"as_amperes","text":"<pre><code>as_amperes() -&gt; float\n</code></pre> <p>Return the current in amperes.</p> RETURNS DESCRIPTION <code>float</code> <p>The current in amperes.</p> Source code in <code>frequenz/quantities/_current.py</code> <pre><code>def as_amperes(self) -&gt; float:\n    \"\"\"Return the current in amperes.\n\n    Returns:\n        The current in amperes.\n    \"\"\"\n    return self._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current.as_milliamperes","title":"as_milliamperes","text":"<pre><code>as_milliamperes() -&gt; float\n</code></pre> <p>Return the current in milliamperes.</p> RETURNS DESCRIPTION <code>float</code> <p>The current in milliamperes.</p> Source code in <code>frequenz/quantities/_current.py</code> <pre><code>def as_milliamperes(self) -&gt; float:\n    \"\"\"Return the current in milliamperes.\n\n    Returns:\n        The current in milliamperes.\n    \"\"\"\n    return self._base_value * 1e3\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current.from_amperes","title":"from_amperes  <code>classmethod</code>","text":"<pre><code>from_amperes(amperes: float) -&gt; Self\n</code></pre> <p>Initialize a new current quantity.</p> PARAMETER DESCRIPTION <code>amperes</code> <p>The current in amperes.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new current quantity.</p> Source code in <code>frequenz/quantities/_current.py</code> <pre><code>@classmethod\ndef from_amperes(cls, amperes: float) -&gt; Self:\n    \"\"\"Initialize a new current quantity.\n\n    Args:\n        amperes: The current in amperes.\n\n    Returns:\n        A new current quantity.\n    \"\"\"\n    return cls._new(amperes)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current.from_milliamperes","title":"from_milliamperes  <code>classmethod</code>","text":"<pre><code>from_milliamperes(milliamperes: float) -&gt; Self\n</code></pre> <p>Initialize a new current quantity.</p> PARAMETER DESCRIPTION <code>milliamperes</code> <p>The current in milliamperes.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new current quantity.</p> Source code in <code>frequenz/quantities/_current.py</code> <pre><code>@classmethod\ndef from_milliamperes(cls, milliamperes: float) -&gt; Self:\n    \"\"\"Initialize a new current quantity.\n\n    Args:\n        milliamperes: The current in milliamperes.\n\n    Returns:\n        A new current quantity.\n    \"\"\"\n    return cls._new(milliamperes, exponent=-3)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(string: str) -&gt; Self\n</code></pre> <p>Return a quantity from a string representation.</p> PARAMETER DESCRIPTION <code>string</code> <p>The string representation of the quantity.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity object with the value given in the string.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the string does not match the expected format.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>@classmethod\ndef from_string(cls, string: str) -&gt; Self:\n    \"\"\"Return a quantity from a string representation.\n\n    Args:\n        string: The string representation of the quantity.\n\n    Returns:\n        A quantity object with the value given in the string.\n\n    Raises:\n        ValueError: If the string does not match the expected format.\n\n    \"\"\"\n    split_string = string.split(\" \")\n\n    if len(split_string) != 2:\n        raise ValueError(\n            f\"Expected a string of the form 'value unit', got {string}\"\n        )\n\n    assert cls._exponent_unit_map is not None\n    exp_map = cls._exponent_unit_map\n\n    for exponent, unit in exp_map.items():\n        if unit == split_string[1]:\n            instance = cls.__new__(cls)\n            try:\n                instance._base_value = float(split_string[0]) * 10**exponent\n            except ValueError as error:\n                raise ValueError(f\"Failed to parse string '{string}'.\") from error\n\n            return instance\n\n    raise ValueError(f\"Unknown unit {split_string[1]}\")\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current.isclose","title":"isclose","text":"<pre><code>isclose(\n    other: Self,\n    rel_tol: float = 1e-09,\n    abs_tol: float = 0.0,\n) -&gt; bool\n</code></pre> <p>Return whether this quantity is close to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n    \"\"\"Return whether this quantity is close to another.\n\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\n    return math.isclose(\n        self._base_value,\n        other._base_value,  # pylint: disable=protected-access\n        rel_tol=rel_tol,\n        abs_tol=abs_tol,\n    )\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current.isinf","title":"isinf","text":"<pre><code>isinf() -&gt; bool\n</code></pre> <p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def isinf(self) -&gt; bool:\n    \"\"\"Return whether this quantity is infinite.\n\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\n    return math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current.isnan","title":"isnan","text":"<pre><code>isnan() -&gt; bool\n</code></pre> <p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def isnan(self) -&gt; bool:\n    \"\"\"Return whether this quantity is NaN.\n\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\n    return math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Current.zero","title":"zero  <code>classmethod</code>","text":"<pre><code>zero() -&gt; Self\n</code></pre> <p>Return a quantity with value 0.0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.0.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n    \"\"\"Return a quantity with value 0.0.\n\n    Returns:\n        A quantity with value 0.0.\n    \"\"\"\n    _zero = cls._zero_cache.get(cls, None)\n    if _zero is None:\n        _zero = cls.__new__(cls)\n        _zero._base_value = 0.0\n        cls._zero_cache[cls] = _zero\n    assert isinstance(_zero, cls)\n    return _zero\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy","title":"frequenz.quantities.Energy","text":"<p>               Bases: <code>Quantity</code></p> <p>An energy quantity.</p> <p>Objects of this type are wrappers around <code>float</code> values and are immutable.</p> <p>The constructors accept a single <code>float</code> value, the <code>as_*()</code> methods return a <code>float</code> value, and each of the arithmetic operators supported by this type are actually implemented using floating-point arithmetic.</p> <p>So all considerations about floating-point arithmetic apply to this type as well.</p> Source code in <code>frequenz/quantities/_energy.py</code> <pre><code>class Energy(\n    Quantity,\n    metaclass=NoDefaultConstructible,\n    exponent_unit_map={\n        0: \"Wh\",\n        3: \"kWh\",\n        6: \"MWh\",\n    },\n):\n    \"\"\"An energy quantity.\n\n    Objects of this type are wrappers around `float` values and are immutable.\n\n    The constructors accept a single `float` value, the `as_*()` methods return a\n    `float` value, and each of the arithmetic operators supported by this type are\n    actually implemented using floating-point arithmetic.\n\n    So all considerations about floating-point arithmetic apply to this type as well.\n    \"\"\"\n\n    @classmethod\n    def from_watt_hours(cls, watt_hours: float) -&gt; Self:\n        \"\"\"Initialize a new energy quantity.\n\n        Args:\n            watt_hours: The energy in watt hours.\n\n        Returns:\n            A new energy quantity.\n        \"\"\"\n        return cls._new(watt_hours)\n\n    @classmethod\n    def from_kilowatt_hours(cls, kilowatt_hours: float) -&gt; Self:\n        \"\"\"Initialize a new energy quantity.\n\n        Args:\n            kilowatt_hours: The energy in kilowatt hours.\n\n        Returns:\n            A new energy quantity.\n        \"\"\"\n        return cls._new(kilowatt_hours, exponent=3)\n\n    @classmethod\n    def from_megawatt_hours(cls, megawatt_hours: float) -&gt; Self:\n        \"\"\"Initialize a new energy quantity.\n\n        Args:\n            megawatt_hours: The energy in megawatt hours.\n\n        Returns:\n            A new energy quantity.\n        \"\"\"\n        return cls._new(megawatt_hours, exponent=6)\n\n    def as_watt_hours(self) -&gt; float:\n        \"\"\"Return the energy in watt hours.\n\n        Returns:\n            The energy in watt hours.\n        \"\"\"\n        return self._base_value\n\n    def as_kilowatt_hours(self) -&gt; float:\n        \"\"\"Return the energy in kilowatt hours.\n\n        Returns:\n            The energy in kilowatt hours.\n        \"\"\"\n        return self._base_value / 1e3\n\n    def as_megawatt_hours(self) -&gt; float:\n        \"\"\"Return the energy in megawatt hours.\n\n        Returns:\n            The energy in megawatt hours.\n        \"\"\"\n        return self._base_value / 1e6\n\n    def __mul__(self, other: float | Percentage) -&gt; Self:\n        \"\"\"Scale this energy by a percentage.\n\n        Args:\n            other: The percentage by which to scale this energy.\n\n        Returns:\n            The scaled energy.\n        \"\"\"\n        from ._percentage import Percentage  # pylint: disable=import-outside-toplevel\n\n        match other:\n            case float():\n                return self._new(self._base_value * other)\n            case Percentage():\n                return self._new(self._base_value * other.as_fraction())\n            case _:\n                return NotImplemented\n\n    # See the comment for Power.__mul__ for why we need the ignore here.\n    @overload  # type: ignore[override]\n    def __truediv__(self, other: float, /) -&gt; Self:\n        \"\"\"Divide this energy by a scalar.\n\n        Args:\n            other: The scalar to divide this energy by.\n\n        Returns:\n            The divided energy.\n        \"\"\"\n\n    @overload\n    def __truediv__(self, other: Self, /) -&gt; float:\n        \"\"\"Return the ratio of this energy to another.\n\n        Args:\n            other: The other energy.\n\n        Returns:\n            The ratio of this energy to another.\n        \"\"\"\n\n    @overload\n    def __truediv__(self, duration: timedelta, /) -&gt; Power:\n        \"\"\"Return a power from dividing this energy by the given duration.\n\n        Args:\n            duration: The duration to divide by.\n\n        Returns:\n            A power from dividing this energy by the given duration.\n        \"\"\"\n\n    @overload\n    def __truediv__(self, power: Power, /) -&gt; timedelta:\n        \"\"\"Return a duration from dividing this energy by the given power.\n\n        Args:\n            power: The power to divide by.\n\n        Returns:\n            A duration from dividing this energy by the given power.\n        \"\"\"\n\n    def __truediv__(\n        self, other: float | Self | timedelta | Power, /\n    ) -&gt; Self | float | Power | timedelta:\n        \"\"\"Return a power or duration from dividing this energy by the given value.\n\n        Args:\n            other: The scalar, energy, power or duration to divide by.\n\n        Returns:\n            A power or duration from dividing this energy by the given value.\n        \"\"\"\n        from ._power import Power  # pylint: disable=import-outside-toplevel\n\n        match other:\n            case float():\n                return super().__truediv__(other)\n            case Energy():\n                return self._base_value / other._base_value\n            case timedelta():\n                return Power._new(self._base_value / (other.total_seconds() / 3600.0))\n            case Power():\n                return timedelta(\n                    seconds=(self._base_value / other._base_value) * 3600.0\n                )\n            case _:\n                return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy.base_unit","title":"base_unit  <code>property</code>","text":"<pre><code>base_unit: str | None\n</code></pre> <p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy.base_value","title":"base_value  <code>property</code>","text":"<pre><code>base_value: float\n</code></pre> <p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy-functions","title":"Functions","text":""},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> <p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __abs__(self) -&gt; Self:\n    \"\"\"Return the absolute value of this quantity.\n\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\n    absolute = type(self).__new__(type(self))\n    absolute._base_value = abs(self._base_value)\n    return absolute\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy.__add__","title":"__add__","text":"<pre><code>__add__(other: Self) -&gt; Self\n</code></pre> <p>Return the sum of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n    \"\"\"Return the sum of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    summe = type(self).__new__(type(self))\n    summe._base_value = self._base_value + other._base_value\n    return summe\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether this quantity is equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Return whether this quantity is equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    # The above check ensures that both quantities are the exact same type, because\n    # `isinstance` returns true for subclasses and superclasses.  But the above check\n    # doesn't help mypy identify the type of other,  so the below line is necessary.\n    assert isinstance(other, self.__class__)\n    return self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy.__format__","title":"__format__","text":"<pre><code>__format__(__format_spec: str) -&gt; str\n</code></pre> <p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.quantities import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n    \"\"\"Return a formatted string representation of this quantity.\n\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n\n    Example:\n        ```python\n        from frequenz.quantities import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n\n    Args:\n        __format_spec: The format specifier.\n\n    Returns:\n        A string representation of this quantity.\n\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\n    keep_trailing_zeros = False\n    if __format_spec != \"\":\n        fspec_parts = __format_spec.split(\".\")\n        if (\n            len(fspec_parts) != 2\n            or fspec_parts[0] not in (\"\", \"0\")\n            or not fspec_parts[1].isdigit()\n        ):\n            raise ValueError(\n                \"Invalid format specifier. Must be empty or `[0].{precision}`\"\n            )\n        if fspec_parts[0] == \"0\":\n            keep_trailing_zeros = True\n        precision = int(fspec_parts[1])\n    else:\n        precision = 3\n    if not self._exponent_unit_map:\n        return f\"{self._base_value:.{precision}f}\"\n\n    if math.isinf(self._base_value) or math.isnan(self._base_value):\n        return f\"{self._base_value} {self._exponent_unit_map[0]}\"\n\n    if abs_value := abs(self._base_value):\n        precision_pow = 10 ** (precision)\n        # Prevent numbers like 999.999999 being rendered as 1000 V\n        # instead of 1 kV.\n        # This could happen because the str formatting function does\n        # rounding as well.\n        # This is an imperfect solution that works for _most_ cases.\n        # isclose parameters were chosen according to the observed cases\n        if math.isclose(abs_value, precision_pow, abs_tol=1e-4, rel_tol=0.01):\n            # If the value is close to the precision, round it\n            exponent = math.ceil(math.log10(precision_pow))\n        else:\n            exponent = math.floor(math.log10(abs_value))\n    else:\n        exponent = 0\n\n    unit_place = exponent - exponent % 3\n    if unit_place &lt; min(self._exponent_unit_map):\n        unit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\n        unit_place = min(self._exponent_unit_map)\n    elif unit_place &gt; max(self._exponent_unit_map):\n        unit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\n        unit_place = max(self._exponent_unit_map)\n    else:\n        unit = self._exponent_unit_map[unit_place]\n\n    value_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\n\n    if value_str in (\"-0\", \"0\"):\n        stripped = value_str\n    else:\n        stripped = value_str.rstrip(\"0\").rstrip(\".\")\n\n    if not keep_trailing_zeros:\n        value_str = stripped\n    unit_str = unit if stripped not in (\"-0\", \"0\") else self._exponent_unit_map[0]\n    return f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than or equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy.__init__","title":"__init__","text":"<pre><code>__init__(value: float, exponent: int = 0) -&gt; None\n</code></pre> <p>Initialize a new quantity.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n    \"\"\"Initialize a new quantity.\n\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\n    self._base_value = value * 10.0**exponent\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(\n    exponent_unit_map: dict[int, str]\n) -&gt; None\n</code></pre> <p>Initialize a new subclass of Quantity.</p> PARAMETER DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n    \"\"\"Initialize a new subclass of Quantity.\n\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n\n    Raises:\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\n    if 0 not in exponent_unit_map:\n        raise ValueError(\"Expected a base unit for the type (for exponent 0)\")\n    cls._exponent_unit_map = exponent_unit_map\n    super().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy.__le__","title":"__le__","text":"<pre><code>__le__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than or equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy.__mod__","title":"__mod__","text":"<pre><code>__mod__(other: Self) -&gt; Self\n</code></pre> <p>Return the remainder of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The remainder of this quantity and another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __mod__(self, other: Self) -&gt; Self:\n    \"\"\"Return the remainder of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The remainder of this quantity and another.\n    \"\"\"\n    return self._new(self._base_value % other._base_value)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy.__mul__","title":"__mul__","text":"<pre><code>__mul__(other: float | Percentage) -&gt; Self\n</code></pre> <p>Scale this energy by a percentage.</p> PARAMETER DESCRIPTION <code>other</code> <p>The percentage by which to scale this energy.</p> <p> TYPE: <code>float | Percentage</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The scaled energy.</p> Source code in <code>frequenz/quantities/_energy.py</code> <pre><code>def __mul__(self, other: float | Percentage) -&gt; Self:\n    \"\"\"Scale this energy by a percentage.\n\n    Args:\n        other: The percentage by which to scale this energy.\n\n    Returns:\n        The scaled energy.\n    \"\"\"\n    from ._percentage import Percentage  # pylint: disable=import-outside-toplevel\n\n    match other:\n        case float():\n            return self._new(self._base_value * other)\n        case Percentage():\n            return self._new(self._base_value * other.as_fraction())\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> <p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __neg__(self) -&gt; Self:\n    \"\"\"Return the negation of this quantity.\n\n    Returns:\n        The negation of this quantity.\n    \"\"\"\n    negation = type(self).__new__(type(self))\n    negation._base_value = -self._base_value\n    return negation\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy.__pos__","title":"__pos__","text":"<pre><code>__pos__() -&gt; Self\n</code></pre> <p>Return this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>This quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __pos__(self) -&gt; Self:\n    \"\"\"Return this quantity.\n\n    Returns:\n        This quantity.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a representation of this quantity.\n\n    Returns:\n        A representation of this quantity.\n    \"\"\"\n    return f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy.__round__","title":"__round__","text":"<pre><code>__round__(ndigits: int | None = None) -&gt; Self\n</code></pre> <p>Round this quantity to the given number of digits.</p> PARAMETER DESCRIPTION <code>ndigits</code> <p>The number of digits to round to.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The rounded quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __round__(self, ndigits: int | None = None) -&gt; Self:\n    \"\"\"Round this quantity to the given number of digits.\n\n    Args:\n        ndigits: The number of digits to round to.\n\n    Returns:\n        The rounded quantity.\n    \"\"\"\n    return self._new(round(self._base_value, ndigits))\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this quantity.\n\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\n    return self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Self) -&gt; Self\n</code></pre> <p>Return the difference of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n    \"\"\"Return the difference of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    difference = type(self).__new__(type(self))\n    difference._base_value = self._base_value - other._base_value\n    return difference\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(\n    other: float | Self | timedelta | Power,\n) -&gt; Self | float | Power | timedelta\n</code></pre> <p>Return a power or duration from dividing this energy by the given value.</p> PARAMETER DESCRIPTION <code>other</code> <p>The scalar, energy, power or duration to divide by.</p> <p> TYPE: <code>float | Self | timedelta | Power</code> </p> RETURNS DESCRIPTION <code>Self | float | Power | timedelta</code> <p>A power or duration from dividing this energy by the given value.</p> Source code in <code>frequenz/quantities/_energy.py</code> <pre><code>def __truediv__(\n    self, other: float | Self | timedelta | Power, /\n) -&gt; Self | float | Power | timedelta:\n    \"\"\"Return a power or duration from dividing this energy by the given value.\n\n    Args:\n        other: The scalar, energy, power or duration to divide by.\n\n    Returns:\n        A power or duration from dividing this energy by the given value.\n    \"\"\"\n    from ._power import Power  # pylint: disable=import-outside-toplevel\n\n    match other:\n        case float():\n            return super().__truediv__(other)\n        case Energy():\n            return self._base_value / other._base_value\n        case timedelta():\n            return Power._new(self._base_value / (other.total_seconds() / 3600.0))\n        case Power():\n            return timedelta(\n                seconds=(self._base_value / other._base_value) * 3600.0\n            )\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy.as_kilowatt_hours","title":"as_kilowatt_hours","text":"<pre><code>as_kilowatt_hours() -&gt; float\n</code></pre> <p>Return the energy in kilowatt hours.</p> RETURNS DESCRIPTION <code>float</code> <p>The energy in kilowatt hours.</p> Source code in <code>frequenz/quantities/_energy.py</code> <pre><code>def as_kilowatt_hours(self) -&gt; float:\n    \"\"\"Return the energy in kilowatt hours.\n\n    Returns:\n        The energy in kilowatt hours.\n    \"\"\"\n    return self._base_value / 1e3\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy.as_megawatt_hours","title":"as_megawatt_hours","text":"<pre><code>as_megawatt_hours() -&gt; float\n</code></pre> <p>Return the energy in megawatt hours.</p> RETURNS DESCRIPTION <code>float</code> <p>The energy in megawatt hours.</p> Source code in <code>frequenz/quantities/_energy.py</code> <pre><code>def as_megawatt_hours(self) -&gt; float:\n    \"\"\"Return the energy in megawatt hours.\n\n    Returns:\n        The energy in megawatt hours.\n    \"\"\"\n    return self._base_value / 1e6\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy.as_watt_hours","title":"as_watt_hours","text":"<pre><code>as_watt_hours() -&gt; float\n</code></pre> <p>Return the energy in watt hours.</p> RETURNS DESCRIPTION <code>float</code> <p>The energy in watt hours.</p> Source code in <code>frequenz/quantities/_energy.py</code> <pre><code>def as_watt_hours(self) -&gt; float:\n    \"\"\"Return the energy in watt hours.\n\n    Returns:\n        The energy in watt hours.\n    \"\"\"\n    return self._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy.from_kilowatt_hours","title":"from_kilowatt_hours  <code>classmethod</code>","text":"<pre><code>from_kilowatt_hours(kilowatt_hours: float) -&gt; Self\n</code></pre> <p>Initialize a new energy quantity.</p> PARAMETER DESCRIPTION <code>kilowatt_hours</code> <p>The energy in kilowatt hours.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new energy quantity.</p> Source code in <code>frequenz/quantities/_energy.py</code> <pre><code>@classmethod\ndef from_kilowatt_hours(cls, kilowatt_hours: float) -&gt; Self:\n    \"\"\"Initialize a new energy quantity.\n\n    Args:\n        kilowatt_hours: The energy in kilowatt hours.\n\n    Returns:\n        A new energy quantity.\n    \"\"\"\n    return cls._new(kilowatt_hours, exponent=3)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy.from_megawatt_hours","title":"from_megawatt_hours  <code>classmethod</code>","text":"<pre><code>from_megawatt_hours(megawatt_hours: float) -&gt; Self\n</code></pre> <p>Initialize a new energy quantity.</p> PARAMETER DESCRIPTION <code>megawatt_hours</code> <p>The energy in megawatt hours.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new energy quantity.</p> Source code in <code>frequenz/quantities/_energy.py</code> <pre><code>@classmethod\ndef from_megawatt_hours(cls, megawatt_hours: float) -&gt; Self:\n    \"\"\"Initialize a new energy quantity.\n\n    Args:\n        megawatt_hours: The energy in megawatt hours.\n\n    Returns:\n        A new energy quantity.\n    \"\"\"\n    return cls._new(megawatt_hours, exponent=6)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(string: str) -&gt; Self\n</code></pre> <p>Return a quantity from a string representation.</p> PARAMETER DESCRIPTION <code>string</code> <p>The string representation of the quantity.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity object with the value given in the string.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the string does not match the expected format.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>@classmethod\ndef from_string(cls, string: str) -&gt; Self:\n    \"\"\"Return a quantity from a string representation.\n\n    Args:\n        string: The string representation of the quantity.\n\n    Returns:\n        A quantity object with the value given in the string.\n\n    Raises:\n        ValueError: If the string does not match the expected format.\n\n    \"\"\"\n    split_string = string.split(\" \")\n\n    if len(split_string) != 2:\n        raise ValueError(\n            f\"Expected a string of the form 'value unit', got {string}\"\n        )\n\n    assert cls._exponent_unit_map is not None\n    exp_map = cls._exponent_unit_map\n\n    for exponent, unit in exp_map.items():\n        if unit == split_string[1]:\n            instance = cls.__new__(cls)\n            try:\n                instance._base_value = float(split_string[0]) * 10**exponent\n            except ValueError as error:\n                raise ValueError(f\"Failed to parse string '{string}'.\") from error\n\n            return instance\n\n    raise ValueError(f\"Unknown unit {split_string[1]}\")\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy.from_watt_hours","title":"from_watt_hours  <code>classmethod</code>","text":"<pre><code>from_watt_hours(watt_hours: float) -&gt; Self\n</code></pre> <p>Initialize a new energy quantity.</p> PARAMETER DESCRIPTION <code>watt_hours</code> <p>The energy in watt hours.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new energy quantity.</p> Source code in <code>frequenz/quantities/_energy.py</code> <pre><code>@classmethod\ndef from_watt_hours(cls, watt_hours: float) -&gt; Self:\n    \"\"\"Initialize a new energy quantity.\n\n    Args:\n        watt_hours: The energy in watt hours.\n\n    Returns:\n        A new energy quantity.\n    \"\"\"\n    return cls._new(watt_hours)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy.isclose","title":"isclose","text":"<pre><code>isclose(\n    other: Self,\n    rel_tol: float = 1e-09,\n    abs_tol: float = 0.0,\n) -&gt; bool\n</code></pre> <p>Return whether this quantity is close to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n    \"\"\"Return whether this quantity is close to another.\n\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\n    return math.isclose(\n        self._base_value,\n        other._base_value,  # pylint: disable=protected-access\n        rel_tol=rel_tol,\n        abs_tol=abs_tol,\n    )\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy.isinf","title":"isinf","text":"<pre><code>isinf() -&gt; bool\n</code></pre> <p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def isinf(self) -&gt; bool:\n    \"\"\"Return whether this quantity is infinite.\n\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\n    return math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy.isnan","title":"isnan","text":"<pre><code>isnan() -&gt; bool\n</code></pre> <p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def isnan(self) -&gt; bool:\n    \"\"\"Return whether this quantity is NaN.\n\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\n    return math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Energy.zero","title":"zero  <code>classmethod</code>","text":"<pre><code>zero() -&gt; Self\n</code></pre> <p>Return a quantity with value 0.0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.0.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n    \"\"\"Return a quantity with value 0.0.\n\n    Returns:\n        A quantity with value 0.0.\n    \"\"\"\n    _zero = cls._zero_cache.get(cls, None)\n    if _zero is None:\n        _zero = cls.__new__(cls)\n        _zero._base_value = 0.0\n        cls._zero_cache[cls] = _zero\n    assert isinstance(_zero, cls)\n    return _zero\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency","title":"frequenz.quantities.Frequency","text":"<p>               Bases: <code>Quantity</code></p> <p>A frequency quantity.</p> <p>Objects of this type are wrappers around <code>float</code> values and are immutable.</p> <p>The constructors accept a single <code>float</code> value, the <code>as_*()</code> methods return a <code>float</code> value, and each of the arithmetic operators supported by this type are actually implemented using floating-point arithmetic.</p> <p>So all considerations about floating-point arithmetic apply to this type as well.</p> Source code in <code>frequenz/quantities/_frequency.py</code> <pre><code>class Frequency(\n    Quantity,\n    metaclass=NoDefaultConstructible,\n    exponent_unit_map={0: \"Hz\", 3: \"kHz\", 6: \"MHz\", 9: \"GHz\"},\n):\n    \"\"\"A frequency quantity.\n\n    Objects of this type are wrappers around `float` values and are immutable.\n\n    The constructors accept a single `float` value, the `as_*()` methods return a\n    `float` value, and each of the arithmetic operators supported by this type are\n    actually implemented using floating-point arithmetic.\n\n    So all considerations about floating-point arithmetic apply to this type as well.\n    \"\"\"\n\n    @classmethod\n    def from_hertz(cls, hertz: float) -&gt; Self:\n        \"\"\"Initialize a new frequency quantity.\n\n        Args:\n            hertz: The frequency in hertz.\n\n        Returns:\n            A new frequency quantity.\n        \"\"\"\n        return cls._new(hertz)\n\n    @classmethod\n    def from_kilohertz(cls, kilohertz: float) -&gt; Self:\n        \"\"\"Initialize a new frequency quantity.\n\n        Args:\n            kilohertz: The frequency in kilohertz.\n\n        Returns:\n            A new frequency quantity.\n        \"\"\"\n        return cls._new(kilohertz, exponent=3)\n\n    @classmethod\n    def from_megahertz(cls, megahertz: float) -&gt; Self:\n        \"\"\"Initialize a new frequency quantity.\n\n        Args:\n            megahertz: The frequency in megahertz.\n\n        Returns:\n            A new frequency quantity.\n        \"\"\"\n        return cls._new(megahertz, exponent=6)\n\n    @classmethod\n    def from_gigahertz(cls, gigahertz: float) -&gt; Self:\n        \"\"\"Initialize a new frequency quantity.\n\n        Args:\n            gigahertz: The frequency in gigahertz.\n\n        Returns:\n            A new frequency quantity.\n        \"\"\"\n        return cls._new(gigahertz, exponent=9)\n\n    def as_hertz(self) -&gt; float:\n        \"\"\"Return the frequency in hertz.\n\n        Returns:\n            The frequency in hertz.\n        \"\"\"\n        return self._base_value\n\n    def as_kilohertz(self) -&gt; float:\n        \"\"\"Return the frequency in kilohertz.\n\n        Returns:\n            The frequency in kilohertz.\n        \"\"\"\n        return self._base_value / 1e3\n\n    def as_megahertz(self) -&gt; float:\n        \"\"\"Return the frequency in megahertz.\n\n        Returns:\n            The frequency in megahertz.\n        \"\"\"\n        return self._base_value / 1e6\n\n    def as_gigahertz(self) -&gt; float:\n        \"\"\"Return the frequency in gigahertz.\n\n        Returns:\n            The frequency in gigahertz.\n        \"\"\"\n        return self._base_value / 1e9\n\n    def period(self) -&gt; timedelta:\n        \"\"\"Return the period of the frequency.\n\n        Returns:\n            The period of the frequency.\n        \"\"\"\n        return timedelta(seconds=1.0 / self._base_value)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.base_unit","title":"base_unit  <code>property</code>","text":"<pre><code>base_unit: str | None\n</code></pre> <p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.base_value","title":"base_value  <code>property</code>","text":"<pre><code>base_value: float\n</code></pre> <p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency-functions","title":"Functions","text":""},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> <p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __abs__(self) -&gt; Self:\n    \"\"\"Return the absolute value of this quantity.\n\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\n    absolute = type(self).__new__(type(self))\n    absolute._base_value = abs(self._base_value)\n    return absolute\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.__add__","title":"__add__","text":"<pre><code>__add__(other: Self) -&gt; Self\n</code></pre> <p>Return the sum of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n    \"\"\"Return the sum of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    summe = type(self).__new__(type(self))\n    summe._base_value = self._base_value + other._base_value\n    return summe\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether this quantity is equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Return whether this quantity is equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    # The above check ensures that both quantities are the exact same type, because\n    # `isinstance` returns true for subclasses and superclasses.  But the above check\n    # doesn't help mypy identify the type of other,  so the below line is necessary.\n    assert isinstance(other, self.__class__)\n    return self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.__format__","title":"__format__","text":"<pre><code>__format__(__format_spec: str) -&gt; str\n</code></pre> <p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.quantities import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n    \"\"\"Return a formatted string representation of this quantity.\n\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n\n    Example:\n        ```python\n        from frequenz.quantities import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n\n    Args:\n        __format_spec: The format specifier.\n\n    Returns:\n        A string representation of this quantity.\n\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\n    keep_trailing_zeros = False\n    if __format_spec != \"\":\n        fspec_parts = __format_spec.split(\".\")\n        if (\n            len(fspec_parts) != 2\n            or fspec_parts[0] not in (\"\", \"0\")\n            or not fspec_parts[1].isdigit()\n        ):\n            raise ValueError(\n                \"Invalid format specifier. Must be empty or `[0].{precision}`\"\n            )\n        if fspec_parts[0] == \"0\":\n            keep_trailing_zeros = True\n        precision = int(fspec_parts[1])\n    else:\n        precision = 3\n    if not self._exponent_unit_map:\n        return f\"{self._base_value:.{precision}f}\"\n\n    if math.isinf(self._base_value) or math.isnan(self._base_value):\n        return f\"{self._base_value} {self._exponent_unit_map[0]}\"\n\n    if abs_value := abs(self._base_value):\n        precision_pow = 10 ** (precision)\n        # Prevent numbers like 999.999999 being rendered as 1000 V\n        # instead of 1 kV.\n        # This could happen because the str formatting function does\n        # rounding as well.\n        # This is an imperfect solution that works for _most_ cases.\n        # isclose parameters were chosen according to the observed cases\n        if math.isclose(abs_value, precision_pow, abs_tol=1e-4, rel_tol=0.01):\n            # If the value is close to the precision, round it\n            exponent = math.ceil(math.log10(precision_pow))\n        else:\n            exponent = math.floor(math.log10(abs_value))\n    else:\n        exponent = 0\n\n    unit_place = exponent - exponent % 3\n    if unit_place &lt; min(self._exponent_unit_map):\n        unit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\n        unit_place = min(self._exponent_unit_map)\n    elif unit_place &gt; max(self._exponent_unit_map):\n        unit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\n        unit_place = max(self._exponent_unit_map)\n    else:\n        unit = self._exponent_unit_map[unit_place]\n\n    value_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\n\n    if value_str in (\"-0\", \"0\"):\n        stripped = value_str\n    else:\n        stripped = value_str.rstrip(\"0\").rstrip(\".\")\n\n    if not keep_trailing_zeros:\n        value_str = stripped\n    unit_str = unit if stripped not in (\"-0\", \"0\") else self._exponent_unit_map[0]\n    return f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than or equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.__init__","title":"__init__","text":"<pre><code>__init__(value: float, exponent: int = 0) -&gt; None\n</code></pre> <p>Initialize a new quantity.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n    \"\"\"Initialize a new quantity.\n\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\n    self._base_value = value * 10.0**exponent\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(\n    exponent_unit_map: dict[int, str]\n) -&gt; None\n</code></pre> <p>Initialize a new subclass of Quantity.</p> PARAMETER DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n    \"\"\"Initialize a new subclass of Quantity.\n\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n\n    Raises:\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\n    if 0 not in exponent_unit_map:\n        raise ValueError(\"Expected a base unit for the type (for exponent 0)\")\n    cls._exponent_unit_map = exponent_unit_map\n    super().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.__le__","title":"__le__","text":"<pre><code>__le__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than or equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.__mod__","title":"__mod__","text":"<pre><code>__mod__(other: Self) -&gt; Self\n</code></pre> <p>Return the remainder of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The remainder of this quantity and another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __mod__(self, other: Self) -&gt; Self:\n    \"\"\"Return the remainder of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The remainder of this quantity and another.\n    \"\"\"\n    return self._new(self._base_value % other._base_value)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.__mul__","title":"__mul__","text":"<pre><code>__mul__(value: float | Percentage) -&gt; Self\n</code></pre> <p>Scale this quantity by a scalar or percentage.</p> PARAMETER DESCRIPTION <code>value</code> <p>The scalar or percentage by which to scale this quantity.</p> <p> TYPE: <code>float | Percentage</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The scaled quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __mul__(self, value: float | Percentage, /) -&gt; Self:\n    \"\"\"Scale this quantity by a scalar or percentage.\n\n    Args:\n        value: The scalar or percentage by which to scale this quantity.\n\n    Returns:\n        The scaled quantity.\n    \"\"\"\n    from ._percentage import Percentage  # pylint: disable=import-outside-toplevel\n\n    match value:\n        case float():\n            return type(self)._new(self._base_value * value)\n        case Percentage():\n            return type(self)._new(self._base_value * value.as_fraction())\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> <p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __neg__(self) -&gt; Self:\n    \"\"\"Return the negation of this quantity.\n\n    Returns:\n        The negation of this quantity.\n    \"\"\"\n    negation = type(self).__new__(type(self))\n    negation._base_value = -self._base_value\n    return negation\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.__pos__","title":"__pos__","text":"<pre><code>__pos__() -&gt; Self\n</code></pre> <p>Return this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>This quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __pos__(self) -&gt; Self:\n    \"\"\"Return this quantity.\n\n    Returns:\n        This quantity.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a representation of this quantity.\n\n    Returns:\n        A representation of this quantity.\n    \"\"\"\n    return f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.__round__","title":"__round__","text":"<pre><code>__round__(ndigits: int | None = None) -&gt; Self\n</code></pre> <p>Round this quantity to the given number of digits.</p> PARAMETER DESCRIPTION <code>ndigits</code> <p>The number of digits to round to.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The rounded quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __round__(self, ndigits: int | None = None) -&gt; Self:\n    \"\"\"Round this quantity to the given number of digits.\n\n    Args:\n        ndigits: The number of digits to round to.\n\n    Returns:\n        The rounded quantity.\n    \"\"\"\n    return self._new(round(self._base_value, ndigits))\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this quantity.\n\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\n    return self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Self) -&gt; Self\n</code></pre> <p>Return the difference of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n    \"\"\"Return the difference of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    difference = type(self).__new__(type(self))\n    difference._base_value = self._base_value - other._base_value\n    return difference\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(value: float | Self) -&gt; Self | float\n</code></pre> <p>Divide this quantity by a scalar or another quantity.</p> PARAMETER DESCRIPTION <code>value</code> <p>The scalar or quantity to divide this quantity by.</p> <p> TYPE: <code>float | Self</code> </p> RETURNS DESCRIPTION <code>Self | float</code> <p>The divided quantity or the ratio of this quantity to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __truediv__(self, value: float | Self, /) -&gt; Self | float:\n    \"\"\"Divide this quantity by a scalar or another quantity.\n\n    Args:\n        value: The scalar or quantity to divide this quantity by.\n\n    Returns:\n        The divided quantity or the ratio of this quantity to another.\n    \"\"\"\n    match value:\n        case float():\n            return type(self)._new(self._base_value / value)\n        case Quantity() if type(value) is type(self):\n            return self._base_value / value._base_value\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.as_gigahertz","title":"as_gigahertz","text":"<pre><code>as_gigahertz() -&gt; float\n</code></pre> <p>Return the frequency in gigahertz.</p> RETURNS DESCRIPTION <code>float</code> <p>The frequency in gigahertz.</p> Source code in <code>frequenz/quantities/_frequency.py</code> <pre><code>def as_gigahertz(self) -&gt; float:\n    \"\"\"Return the frequency in gigahertz.\n\n    Returns:\n        The frequency in gigahertz.\n    \"\"\"\n    return self._base_value / 1e9\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.as_hertz","title":"as_hertz","text":"<pre><code>as_hertz() -&gt; float\n</code></pre> <p>Return the frequency in hertz.</p> RETURNS DESCRIPTION <code>float</code> <p>The frequency in hertz.</p> Source code in <code>frequenz/quantities/_frequency.py</code> <pre><code>def as_hertz(self) -&gt; float:\n    \"\"\"Return the frequency in hertz.\n\n    Returns:\n        The frequency in hertz.\n    \"\"\"\n    return self._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.as_kilohertz","title":"as_kilohertz","text":"<pre><code>as_kilohertz() -&gt; float\n</code></pre> <p>Return the frequency in kilohertz.</p> RETURNS DESCRIPTION <code>float</code> <p>The frequency in kilohertz.</p> Source code in <code>frequenz/quantities/_frequency.py</code> <pre><code>def as_kilohertz(self) -&gt; float:\n    \"\"\"Return the frequency in kilohertz.\n\n    Returns:\n        The frequency in kilohertz.\n    \"\"\"\n    return self._base_value / 1e3\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.as_megahertz","title":"as_megahertz","text":"<pre><code>as_megahertz() -&gt; float\n</code></pre> <p>Return the frequency in megahertz.</p> RETURNS DESCRIPTION <code>float</code> <p>The frequency in megahertz.</p> Source code in <code>frequenz/quantities/_frequency.py</code> <pre><code>def as_megahertz(self) -&gt; float:\n    \"\"\"Return the frequency in megahertz.\n\n    Returns:\n        The frequency in megahertz.\n    \"\"\"\n    return self._base_value / 1e6\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.from_gigahertz","title":"from_gigahertz  <code>classmethod</code>","text":"<pre><code>from_gigahertz(gigahertz: float) -&gt; Self\n</code></pre> <p>Initialize a new frequency quantity.</p> PARAMETER DESCRIPTION <code>gigahertz</code> <p>The frequency in gigahertz.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new frequency quantity.</p> Source code in <code>frequenz/quantities/_frequency.py</code> <pre><code>@classmethod\ndef from_gigahertz(cls, gigahertz: float) -&gt; Self:\n    \"\"\"Initialize a new frequency quantity.\n\n    Args:\n        gigahertz: The frequency in gigahertz.\n\n    Returns:\n        A new frequency quantity.\n    \"\"\"\n    return cls._new(gigahertz, exponent=9)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.from_hertz","title":"from_hertz  <code>classmethod</code>","text":"<pre><code>from_hertz(hertz: float) -&gt; Self\n</code></pre> <p>Initialize a new frequency quantity.</p> PARAMETER DESCRIPTION <code>hertz</code> <p>The frequency in hertz.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new frequency quantity.</p> Source code in <code>frequenz/quantities/_frequency.py</code> <pre><code>@classmethod\ndef from_hertz(cls, hertz: float) -&gt; Self:\n    \"\"\"Initialize a new frequency quantity.\n\n    Args:\n        hertz: The frequency in hertz.\n\n    Returns:\n        A new frequency quantity.\n    \"\"\"\n    return cls._new(hertz)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.from_kilohertz","title":"from_kilohertz  <code>classmethod</code>","text":"<pre><code>from_kilohertz(kilohertz: float) -&gt; Self\n</code></pre> <p>Initialize a new frequency quantity.</p> PARAMETER DESCRIPTION <code>kilohertz</code> <p>The frequency in kilohertz.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new frequency quantity.</p> Source code in <code>frequenz/quantities/_frequency.py</code> <pre><code>@classmethod\ndef from_kilohertz(cls, kilohertz: float) -&gt; Self:\n    \"\"\"Initialize a new frequency quantity.\n\n    Args:\n        kilohertz: The frequency in kilohertz.\n\n    Returns:\n        A new frequency quantity.\n    \"\"\"\n    return cls._new(kilohertz, exponent=3)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.from_megahertz","title":"from_megahertz  <code>classmethod</code>","text":"<pre><code>from_megahertz(megahertz: float) -&gt; Self\n</code></pre> <p>Initialize a new frequency quantity.</p> PARAMETER DESCRIPTION <code>megahertz</code> <p>The frequency in megahertz.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new frequency quantity.</p> Source code in <code>frequenz/quantities/_frequency.py</code> <pre><code>@classmethod\ndef from_megahertz(cls, megahertz: float) -&gt; Self:\n    \"\"\"Initialize a new frequency quantity.\n\n    Args:\n        megahertz: The frequency in megahertz.\n\n    Returns:\n        A new frequency quantity.\n    \"\"\"\n    return cls._new(megahertz, exponent=6)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(string: str) -&gt; Self\n</code></pre> <p>Return a quantity from a string representation.</p> PARAMETER DESCRIPTION <code>string</code> <p>The string representation of the quantity.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity object with the value given in the string.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the string does not match the expected format.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>@classmethod\ndef from_string(cls, string: str) -&gt; Self:\n    \"\"\"Return a quantity from a string representation.\n\n    Args:\n        string: The string representation of the quantity.\n\n    Returns:\n        A quantity object with the value given in the string.\n\n    Raises:\n        ValueError: If the string does not match the expected format.\n\n    \"\"\"\n    split_string = string.split(\" \")\n\n    if len(split_string) != 2:\n        raise ValueError(\n            f\"Expected a string of the form 'value unit', got {string}\"\n        )\n\n    assert cls._exponent_unit_map is not None\n    exp_map = cls._exponent_unit_map\n\n    for exponent, unit in exp_map.items():\n        if unit == split_string[1]:\n            instance = cls.__new__(cls)\n            try:\n                instance._base_value = float(split_string[0]) * 10**exponent\n            except ValueError as error:\n                raise ValueError(f\"Failed to parse string '{string}'.\") from error\n\n            return instance\n\n    raise ValueError(f\"Unknown unit {split_string[1]}\")\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.isclose","title":"isclose","text":"<pre><code>isclose(\n    other: Self,\n    rel_tol: float = 1e-09,\n    abs_tol: float = 0.0,\n) -&gt; bool\n</code></pre> <p>Return whether this quantity is close to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n    \"\"\"Return whether this quantity is close to another.\n\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\n    return math.isclose(\n        self._base_value,\n        other._base_value,  # pylint: disable=protected-access\n        rel_tol=rel_tol,\n        abs_tol=abs_tol,\n    )\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.isinf","title":"isinf","text":"<pre><code>isinf() -&gt; bool\n</code></pre> <p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def isinf(self) -&gt; bool:\n    \"\"\"Return whether this quantity is infinite.\n\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\n    return math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.isnan","title":"isnan","text":"<pre><code>isnan() -&gt; bool\n</code></pre> <p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def isnan(self) -&gt; bool:\n    \"\"\"Return whether this quantity is NaN.\n\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\n    return math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.period","title":"period","text":"<pre><code>period() -&gt; timedelta\n</code></pre> <p>Return the period of the frequency.</p> RETURNS DESCRIPTION <code>timedelta</code> <p>The period of the frequency.</p> Source code in <code>frequenz/quantities/_frequency.py</code> <pre><code>def period(self) -&gt; timedelta:\n    \"\"\"Return the period of the frequency.\n\n    Returns:\n        The period of the frequency.\n    \"\"\"\n    return timedelta(seconds=1.0 / self._base_value)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Frequency.zero","title":"zero  <code>classmethod</code>","text":"<pre><code>zero() -&gt; Self\n</code></pre> <p>Return a quantity with value 0.0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.0.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n    \"\"\"Return a quantity with value 0.0.\n\n    Returns:\n        A quantity with value 0.0.\n    \"\"\"\n    _zero = cls._zero_cache.get(cls, None)\n    if _zero is None:\n        _zero = cls.__new__(cls)\n        _zero._base_value = 0.0\n        cls._zero_cache[cls] = _zero\n    assert isinstance(_zero, cls)\n    return _zero\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage","title":"frequenz.quantities.Percentage","text":"<p>               Bases: <code>Quantity</code></p> <p>A percentage quantity.</p> <p>Objects of this type are wrappers around <code>float</code> values and are immutable.</p> <p>The constructors accept a single <code>float</code> value, the <code>as_*()</code> methods return a <code>float</code> value, and each of the arithmetic operators supported by this type are actually implemented using floating-point arithmetic.</p> <p>So all considerations about floating-point arithmetic apply to this type as well.</p> Source code in <code>frequenz/quantities/_percentage.py</code> <pre><code>class Percentage(\n    Quantity,\n    metaclass=NoDefaultConstructible,\n    exponent_unit_map={0: \"%\"},\n):\n    \"\"\"A percentage quantity.\n\n    Objects of this type are wrappers around `float` values and are immutable.\n\n    The constructors accept a single `float` value, the `as_*()` methods return a\n    `float` value, and each of the arithmetic operators supported by this type are\n    actually implemented using floating-point arithmetic.\n\n    So all considerations about floating-point arithmetic apply to this type as well.\n    \"\"\"\n\n    @classmethod\n    def from_percent(cls, percent: float) -&gt; Self:\n        \"\"\"Initialize a new percentage quantity from a percent value.\n\n        Args:\n            percent: The percent value, normally in the 0.0-100.0 range.\n\n        Returns:\n            A new percentage quantity.\n        \"\"\"\n        return cls._new(percent)\n\n    @classmethod\n    def from_fraction(cls, fraction: float) -&gt; Self:\n        \"\"\"Initialize a new percentage quantity from a fraction.\n\n        Args:\n            fraction: The fraction, normally in the 0.0-1.0 range.\n\n        Returns:\n            A new percentage quantity.\n        \"\"\"\n        return cls._new(fraction * 100)\n\n    def as_percent(self) -&gt; float:\n        \"\"\"Return this quantity as a percentage.\n\n        Returns:\n            This quantity as a percentage.\n        \"\"\"\n        return self._base_value\n\n    def as_fraction(self) -&gt; float:\n        \"\"\"Return this quantity as a fraction.\n\n        Returns:\n            This quantity as a fraction.\n        \"\"\"\n        return self._base_value / 100\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage.base_unit","title":"base_unit  <code>property</code>","text":"<pre><code>base_unit: str | None\n</code></pre> <p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage.base_value","title":"base_value  <code>property</code>","text":"<pre><code>base_value: float\n</code></pre> <p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage-functions","title":"Functions","text":""},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> <p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __abs__(self) -&gt; Self:\n    \"\"\"Return the absolute value of this quantity.\n\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\n    absolute = type(self).__new__(type(self))\n    absolute._base_value = abs(self._base_value)\n    return absolute\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage.__add__","title":"__add__","text":"<pre><code>__add__(other: Self) -&gt; Self\n</code></pre> <p>Return the sum of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n    \"\"\"Return the sum of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    summe = type(self).__new__(type(self))\n    summe._base_value = self._base_value + other._base_value\n    return summe\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether this quantity is equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Return whether this quantity is equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    # The above check ensures that both quantities are the exact same type, because\n    # `isinstance` returns true for subclasses and superclasses.  But the above check\n    # doesn't help mypy identify the type of other,  so the below line is necessary.\n    assert isinstance(other, self.__class__)\n    return self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage.__format__","title":"__format__","text":"<pre><code>__format__(__format_spec: str) -&gt; str\n</code></pre> <p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.quantities import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n    \"\"\"Return a formatted string representation of this quantity.\n\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n\n    Example:\n        ```python\n        from frequenz.quantities import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n\n    Args:\n        __format_spec: The format specifier.\n\n    Returns:\n        A string representation of this quantity.\n\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\n    keep_trailing_zeros = False\n    if __format_spec != \"\":\n        fspec_parts = __format_spec.split(\".\")\n        if (\n            len(fspec_parts) != 2\n            or fspec_parts[0] not in (\"\", \"0\")\n            or not fspec_parts[1].isdigit()\n        ):\n            raise ValueError(\n                \"Invalid format specifier. Must be empty or `[0].{precision}`\"\n            )\n        if fspec_parts[0] == \"0\":\n            keep_trailing_zeros = True\n        precision = int(fspec_parts[1])\n    else:\n        precision = 3\n    if not self._exponent_unit_map:\n        return f\"{self._base_value:.{precision}f}\"\n\n    if math.isinf(self._base_value) or math.isnan(self._base_value):\n        return f\"{self._base_value} {self._exponent_unit_map[0]}\"\n\n    if abs_value := abs(self._base_value):\n        precision_pow = 10 ** (precision)\n        # Prevent numbers like 999.999999 being rendered as 1000 V\n        # instead of 1 kV.\n        # This could happen because the str formatting function does\n        # rounding as well.\n        # This is an imperfect solution that works for _most_ cases.\n        # isclose parameters were chosen according to the observed cases\n        if math.isclose(abs_value, precision_pow, abs_tol=1e-4, rel_tol=0.01):\n            # If the value is close to the precision, round it\n            exponent = math.ceil(math.log10(precision_pow))\n        else:\n            exponent = math.floor(math.log10(abs_value))\n    else:\n        exponent = 0\n\n    unit_place = exponent - exponent % 3\n    if unit_place &lt; min(self._exponent_unit_map):\n        unit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\n        unit_place = min(self._exponent_unit_map)\n    elif unit_place &gt; max(self._exponent_unit_map):\n        unit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\n        unit_place = max(self._exponent_unit_map)\n    else:\n        unit = self._exponent_unit_map[unit_place]\n\n    value_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\n\n    if value_str in (\"-0\", \"0\"):\n        stripped = value_str\n    else:\n        stripped = value_str.rstrip(\"0\").rstrip(\".\")\n\n    if not keep_trailing_zeros:\n        value_str = stripped\n    unit_str = unit if stripped not in (\"-0\", \"0\") else self._exponent_unit_map[0]\n    return f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than or equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage.__init__","title":"__init__","text":"<pre><code>__init__(value: float, exponent: int = 0) -&gt; None\n</code></pre> <p>Initialize a new quantity.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n    \"\"\"Initialize a new quantity.\n\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\n    self._base_value = value * 10.0**exponent\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(\n    exponent_unit_map: dict[int, str]\n) -&gt; None\n</code></pre> <p>Initialize a new subclass of Quantity.</p> PARAMETER DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n    \"\"\"Initialize a new subclass of Quantity.\n\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n\n    Raises:\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\n    if 0 not in exponent_unit_map:\n        raise ValueError(\"Expected a base unit for the type (for exponent 0)\")\n    cls._exponent_unit_map = exponent_unit_map\n    super().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage.__le__","title":"__le__","text":"<pre><code>__le__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than or equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage.__mod__","title":"__mod__","text":"<pre><code>__mod__(other: Self) -&gt; Self\n</code></pre> <p>Return the remainder of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The remainder of this quantity and another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __mod__(self, other: Self) -&gt; Self:\n    \"\"\"Return the remainder of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The remainder of this quantity and another.\n    \"\"\"\n    return self._new(self._base_value % other._base_value)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage.__mul__","title":"__mul__","text":"<pre><code>__mul__(value: float | Percentage) -&gt; Self\n</code></pre> <p>Scale this quantity by a scalar or percentage.</p> PARAMETER DESCRIPTION <code>value</code> <p>The scalar or percentage by which to scale this quantity.</p> <p> TYPE: <code>float | Percentage</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The scaled quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __mul__(self, value: float | Percentage, /) -&gt; Self:\n    \"\"\"Scale this quantity by a scalar or percentage.\n\n    Args:\n        value: The scalar or percentage by which to scale this quantity.\n\n    Returns:\n        The scaled quantity.\n    \"\"\"\n    from ._percentage import Percentage  # pylint: disable=import-outside-toplevel\n\n    match value:\n        case float():\n            return type(self)._new(self._base_value * value)\n        case Percentage():\n            return type(self)._new(self._base_value * value.as_fraction())\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> <p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __neg__(self) -&gt; Self:\n    \"\"\"Return the negation of this quantity.\n\n    Returns:\n        The negation of this quantity.\n    \"\"\"\n    negation = type(self).__new__(type(self))\n    negation._base_value = -self._base_value\n    return negation\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage.__pos__","title":"__pos__","text":"<pre><code>__pos__() -&gt; Self\n</code></pre> <p>Return this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>This quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __pos__(self) -&gt; Self:\n    \"\"\"Return this quantity.\n\n    Returns:\n        This quantity.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a representation of this quantity.\n\n    Returns:\n        A representation of this quantity.\n    \"\"\"\n    return f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage.__round__","title":"__round__","text":"<pre><code>__round__(ndigits: int | None = None) -&gt; Self\n</code></pre> <p>Round this quantity to the given number of digits.</p> PARAMETER DESCRIPTION <code>ndigits</code> <p>The number of digits to round to.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The rounded quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __round__(self, ndigits: int | None = None) -&gt; Self:\n    \"\"\"Round this quantity to the given number of digits.\n\n    Args:\n        ndigits: The number of digits to round to.\n\n    Returns:\n        The rounded quantity.\n    \"\"\"\n    return self._new(round(self._base_value, ndigits))\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this quantity.\n\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\n    return self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Self) -&gt; Self\n</code></pre> <p>Return the difference of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n    \"\"\"Return the difference of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    difference = type(self).__new__(type(self))\n    difference._base_value = self._base_value - other._base_value\n    return difference\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(value: float | Self) -&gt; Self | float\n</code></pre> <p>Divide this quantity by a scalar or another quantity.</p> PARAMETER DESCRIPTION <code>value</code> <p>The scalar or quantity to divide this quantity by.</p> <p> TYPE: <code>float | Self</code> </p> RETURNS DESCRIPTION <code>Self | float</code> <p>The divided quantity or the ratio of this quantity to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __truediv__(self, value: float | Self, /) -&gt; Self | float:\n    \"\"\"Divide this quantity by a scalar or another quantity.\n\n    Args:\n        value: The scalar or quantity to divide this quantity by.\n\n    Returns:\n        The divided quantity or the ratio of this quantity to another.\n    \"\"\"\n    match value:\n        case float():\n            return type(self)._new(self._base_value / value)\n        case Quantity() if type(value) is type(self):\n            return self._base_value / value._base_value\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage.as_fraction","title":"as_fraction","text":"<pre><code>as_fraction() -&gt; float\n</code></pre> <p>Return this quantity as a fraction.</p> RETURNS DESCRIPTION <code>float</code> <p>This quantity as a fraction.</p> Source code in <code>frequenz/quantities/_percentage.py</code> <pre><code>def as_fraction(self) -&gt; float:\n    \"\"\"Return this quantity as a fraction.\n\n    Returns:\n        This quantity as a fraction.\n    \"\"\"\n    return self._base_value / 100\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage.as_percent","title":"as_percent","text":"<pre><code>as_percent() -&gt; float\n</code></pre> <p>Return this quantity as a percentage.</p> RETURNS DESCRIPTION <code>float</code> <p>This quantity as a percentage.</p> Source code in <code>frequenz/quantities/_percentage.py</code> <pre><code>def as_percent(self) -&gt; float:\n    \"\"\"Return this quantity as a percentage.\n\n    Returns:\n        This quantity as a percentage.\n    \"\"\"\n    return self._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage.from_fraction","title":"from_fraction  <code>classmethod</code>","text":"<pre><code>from_fraction(fraction: float) -&gt; Self\n</code></pre> <p>Initialize a new percentage quantity from a fraction.</p> PARAMETER DESCRIPTION <code>fraction</code> <p>The fraction, normally in the 0.0-1.0 range.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new percentage quantity.</p> Source code in <code>frequenz/quantities/_percentage.py</code> <pre><code>@classmethod\ndef from_fraction(cls, fraction: float) -&gt; Self:\n    \"\"\"Initialize a new percentage quantity from a fraction.\n\n    Args:\n        fraction: The fraction, normally in the 0.0-1.0 range.\n\n    Returns:\n        A new percentage quantity.\n    \"\"\"\n    return cls._new(fraction * 100)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage.from_percent","title":"from_percent  <code>classmethod</code>","text":"<pre><code>from_percent(percent: float) -&gt; Self\n</code></pre> <p>Initialize a new percentage quantity from a percent value.</p> PARAMETER DESCRIPTION <code>percent</code> <p>The percent value, normally in the 0.0-100.0 range.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new percentage quantity.</p> Source code in <code>frequenz/quantities/_percentage.py</code> <pre><code>@classmethod\ndef from_percent(cls, percent: float) -&gt; Self:\n    \"\"\"Initialize a new percentage quantity from a percent value.\n\n    Args:\n        percent: The percent value, normally in the 0.0-100.0 range.\n\n    Returns:\n        A new percentage quantity.\n    \"\"\"\n    return cls._new(percent)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(string: str) -&gt; Self\n</code></pre> <p>Return a quantity from a string representation.</p> PARAMETER DESCRIPTION <code>string</code> <p>The string representation of the quantity.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity object with the value given in the string.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the string does not match the expected format.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>@classmethod\ndef from_string(cls, string: str) -&gt; Self:\n    \"\"\"Return a quantity from a string representation.\n\n    Args:\n        string: The string representation of the quantity.\n\n    Returns:\n        A quantity object with the value given in the string.\n\n    Raises:\n        ValueError: If the string does not match the expected format.\n\n    \"\"\"\n    split_string = string.split(\" \")\n\n    if len(split_string) != 2:\n        raise ValueError(\n            f\"Expected a string of the form 'value unit', got {string}\"\n        )\n\n    assert cls._exponent_unit_map is not None\n    exp_map = cls._exponent_unit_map\n\n    for exponent, unit in exp_map.items():\n        if unit == split_string[1]:\n            instance = cls.__new__(cls)\n            try:\n                instance._base_value = float(split_string[0]) * 10**exponent\n            except ValueError as error:\n                raise ValueError(f\"Failed to parse string '{string}'.\") from error\n\n            return instance\n\n    raise ValueError(f\"Unknown unit {split_string[1]}\")\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage.isclose","title":"isclose","text":"<pre><code>isclose(\n    other: Self,\n    rel_tol: float = 1e-09,\n    abs_tol: float = 0.0,\n) -&gt; bool\n</code></pre> <p>Return whether this quantity is close to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n    \"\"\"Return whether this quantity is close to another.\n\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\n    return math.isclose(\n        self._base_value,\n        other._base_value,  # pylint: disable=protected-access\n        rel_tol=rel_tol,\n        abs_tol=abs_tol,\n    )\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage.isinf","title":"isinf","text":"<pre><code>isinf() -&gt; bool\n</code></pre> <p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def isinf(self) -&gt; bool:\n    \"\"\"Return whether this quantity is infinite.\n\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\n    return math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage.isnan","title":"isnan","text":"<pre><code>isnan() -&gt; bool\n</code></pre> <p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def isnan(self) -&gt; bool:\n    \"\"\"Return whether this quantity is NaN.\n\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\n    return math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Percentage.zero","title":"zero  <code>classmethod</code>","text":"<pre><code>zero() -&gt; Self\n</code></pre> <p>Return a quantity with value 0.0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.0.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n    \"\"\"Return a quantity with value 0.0.\n\n    Returns:\n        A quantity with value 0.0.\n    \"\"\"\n    _zero = cls._zero_cache.get(cls, None)\n    if _zero is None:\n        _zero = cls.__new__(cls)\n        _zero._base_value = 0.0\n        cls._zero_cache[cls] = _zero\n    assert isinstance(_zero, cls)\n    return _zero\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power","title":"frequenz.quantities.Power","text":"<p>               Bases: <code>Quantity</code></p> <p>A power quantity.</p> <p>Objects of this type are wrappers around <code>float</code> values and are immutable.</p> <p>The constructors accept a single <code>float</code> value, the <code>as_*()</code> methods return a <code>float</code> value, and each of the arithmetic operators supported by this type are actually implemented using floating-point arithmetic.</p> <p>So all considerations about floating-point arithmetic apply to this type as well.</p> Source code in <code>frequenz/quantities/_power.py</code> <pre><code>class Power(\n    Quantity,\n    metaclass=NoDefaultConstructible,\n    exponent_unit_map={\n        -3: \"mW\",\n        0: \"W\",\n        3: \"kW\",\n        6: \"MW\",\n    },\n):\n    \"\"\"A power quantity.\n\n    Objects of this type are wrappers around `float` values and are immutable.\n\n    The constructors accept a single `float` value, the `as_*()` methods return a\n    `float` value, and each of the arithmetic operators supported by this type are\n    actually implemented using floating-point arithmetic.\n\n    So all considerations about floating-point arithmetic apply to this type as well.\n    \"\"\"\n\n    @classmethod\n    def from_watts(cls, watts: float) -&gt; Self:\n        \"\"\"Initialize a new power quantity.\n\n        Args:\n            watts: The power in watts.\n\n        Returns:\n            A new power quantity.\n        \"\"\"\n        return cls._new(watts)\n\n    @classmethod\n    def from_milliwatts(cls, milliwatts: float) -&gt; Self:\n        \"\"\"Initialize a new power quantity.\n\n        Args:\n            milliwatts: The power in milliwatts.\n\n        Returns:\n            A new power quantity.\n        \"\"\"\n        return cls._new(milliwatts, exponent=-3)\n\n    @classmethod\n    def from_kilowatts(cls, kilowatts: float) -&gt; Self:\n        \"\"\"Initialize a new power quantity.\n\n        Args:\n            kilowatts: The power in kilowatts.\n\n        Returns:\n            A new power quantity.\n        \"\"\"\n        return cls._new(kilowatts, exponent=3)\n\n    @classmethod\n    def from_megawatts(cls, megawatts: float) -&gt; Self:\n        \"\"\"Initialize a new power quantity.\n\n        Args:\n            megawatts: The power in megawatts.\n\n        Returns:\n            A new power quantity.\n        \"\"\"\n        return cls._new(megawatts, exponent=6)\n\n    def as_watts(self) -&gt; float:\n        \"\"\"Return the power in watts.\n\n        Returns:\n            The power in watts.\n        \"\"\"\n        return self._base_value\n\n    def as_kilowatts(self) -&gt; float:\n        \"\"\"Return the power in kilowatts.\n\n        Returns:\n            The power in kilowatts.\n        \"\"\"\n        return self._base_value / 1e3\n\n    def as_megawatts(self) -&gt; float:\n        \"\"\"Return the power in megawatts.\n\n        Returns:\n            The power in megawatts.\n        \"\"\"\n        return self._base_value / 1e6\n\n    # We need the ignore here because otherwise mypy will give this error:\n    # &gt; Overloaded operator methods can't have wider argument types in overrides\n    # The problem seems to be when the other type implements an **incompatible**\n    # __rmul__ method, which is not the case here, so we should be safe.\n    # Please see this example:\n    # https://github.com/python/mypy/blob/c26f1297d4f19d2d1124a30efc97caebb8c28616/test-data/unit/check-overloading.test#L4738C1-L4769C55\n    # And a discussion in a mypy issue here:\n    # https://github.com/python/mypy/issues/4985#issuecomment-389692396\n    @overload  # type: ignore[override]\n    def __mul__(self, scalar: float, /) -&gt; Self:\n        \"\"\"Scale this power by a scalar.\n\n        Args:\n            scalar: The scalar by which to scale this power.\n\n        Returns:\n            The scaled power.\n        \"\"\"\n\n    @overload\n    def __mul__(self, percent: Percentage, /) -&gt; Self:\n        \"\"\"Scale this power by a percentage.\n\n        Args:\n            percent: The percentage by which to scale this power.\n\n        Returns:\n            The scaled power.\n        \"\"\"\n\n    @overload\n    def __mul__(self, other: timedelta, /) -&gt; Energy:\n        \"\"\"Return an energy from multiplying this power by the given duration.\n\n        Args:\n            other: The duration to multiply by.\n\n        Returns:\n            The calculated energy.\n        \"\"\"\n\n    def __mul__(self, other: float | Percentage | timedelta, /) -&gt; Self | Energy:\n        \"\"\"Return a power or energy from multiplying this power by the given value.\n\n        Args:\n            other: The scalar, percentage or duration to multiply by.\n\n        Returns:\n            A power or energy.\n        \"\"\"\n        from ._energy import Energy  # pylint: disable=import-outside-toplevel\n        from ._percentage import Percentage  # pylint: disable=import-outside-toplevel\n\n        match other:\n            case float() | Percentage():\n                return super().__mul__(other)\n            case timedelta():\n                return Energy._new(self._base_value * other.total_seconds() / 3600.0)\n            case _:\n                return NotImplemented\n\n    # See the comment for Power.__mul__ for why we need the ignore here.\n    @overload  # type: ignore[override]\n    def __truediv__(self, other: float, /) -&gt; Self:\n        \"\"\"Divide this power by a scalar.\n\n        Args:\n            other: The scalar to divide this power by.\n\n        Returns:\n            The divided power.\n        \"\"\"\n\n    @overload\n    def __truediv__(self, other: Self, /) -&gt; float:\n        \"\"\"Return the ratio of this power to another.\n\n        Args:\n            other: The other power.\n\n        Returns:\n            The ratio of this power to another.\n        \"\"\"\n\n    @overload\n    def __truediv__(self, current: Current, /) -&gt; Voltage:\n        \"\"\"Return a voltage from dividing this power by the given current.\n\n        Args:\n            current: The current to divide by.\n\n        Returns:\n            A voltage from dividing this power by the a current.\n        \"\"\"\n\n    @overload\n    def __truediv__(self, voltage: Voltage, /) -&gt; Current:\n        \"\"\"Return a current from dividing this power by the given voltage.\n\n        Args:\n            voltage: The voltage to divide by.\n\n        Returns:\n            A current from dividing this power by a voltage.\n        \"\"\"\n\n    def __truediv__(\n        self, other: float | Self | Current | Voltage, /\n    ) -&gt; Self | float | Voltage | Current:\n        \"\"\"Return a current or voltage from dividing this power by the given value.\n\n        Args:\n            other: The scalar, power, current or voltage to divide by.\n\n        Returns:\n            A current or voltage from dividing this power by the given value.\n        \"\"\"\n        from ._current import Current  # pylint: disable=import-outside-toplevel\n        from ._voltage import Voltage  # pylint: disable=import-outside-toplevel\n\n        match other:\n            case float():\n                return super().__truediv__(other)\n            case Power():\n                return self._base_value / other._base_value\n            case Current():\n                return Voltage._new(self._base_value / other._base_value)\n            case Voltage():\n                return Current._new(self._base_value / other._base_value)\n            case _:\n                return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.base_unit","title":"base_unit  <code>property</code>","text":"<pre><code>base_unit: str | None\n</code></pre> <p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.base_value","title":"base_value  <code>property</code>","text":"<pre><code>base_value: float\n</code></pre> <p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power-functions","title":"Functions","text":""},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> <p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __abs__(self) -&gt; Self:\n    \"\"\"Return the absolute value of this quantity.\n\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\n    absolute = type(self).__new__(type(self))\n    absolute._base_value = abs(self._base_value)\n    return absolute\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.__add__","title":"__add__","text":"<pre><code>__add__(other: Self) -&gt; Self\n</code></pre> <p>Return the sum of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n    \"\"\"Return the sum of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    summe = type(self).__new__(type(self))\n    summe._base_value = self._base_value + other._base_value\n    return summe\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether this quantity is equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Return whether this quantity is equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    # The above check ensures that both quantities are the exact same type, because\n    # `isinstance` returns true for subclasses and superclasses.  But the above check\n    # doesn't help mypy identify the type of other,  so the below line is necessary.\n    assert isinstance(other, self.__class__)\n    return self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.__format__","title":"__format__","text":"<pre><code>__format__(__format_spec: str) -&gt; str\n</code></pre> <p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.quantities import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n    \"\"\"Return a formatted string representation of this quantity.\n\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n\n    Example:\n        ```python\n        from frequenz.quantities import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n\n    Args:\n        __format_spec: The format specifier.\n\n    Returns:\n        A string representation of this quantity.\n\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\n    keep_trailing_zeros = False\n    if __format_spec != \"\":\n        fspec_parts = __format_spec.split(\".\")\n        if (\n            len(fspec_parts) != 2\n            or fspec_parts[0] not in (\"\", \"0\")\n            or not fspec_parts[1].isdigit()\n        ):\n            raise ValueError(\n                \"Invalid format specifier. Must be empty or `[0].{precision}`\"\n            )\n        if fspec_parts[0] == \"0\":\n            keep_trailing_zeros = True\n        precision = int(fspec_parts[1])\n    else:\n        precision = 3\n    if not self._exponent_unit_map:\n        return f\"{self._base_value:.{precision}f}\"\n\n    if math.isinf(self._base_value) or math.isnan(self._base_value):\n        return f\"{self._base_value} {self._exponent_unit_map[0]}\"\n\n    if abs_value := abs(self._base_value):\n        precision_pow = 10 ** (precision)\n        # Prevent numbers like 999.999999 being rendered as 1000 V\n        # instead of 1 kV.\n        # This could happen because the str formatting function does\n        # rounding as well.\n        # This is an imperfect solution that works for _most_ cases.\n        # isclose parameters were chosen according to the observed cases\n        if math.isclose(abs_value, precision_pow, abs_tol=1e-4, rel_tol=0.01):\n            # If the value is close to the precision, round it\n            exponent = math.ceil(math.log10(precision_pow))\n        else:\n            exponent = math.floor(math.log10(abs_value))\n    else:\n        exponent = 0\n\n    unit_place = exponent - exponent % 3\n    if unit_place &lt; min(self._exponent_unit_map):\n        unit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\n        unit_place = min(self._exponent_unit_map)\n    elif unit_place &gt; max(self._exponent_unit_map):\n        unit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\n        unit_place = max(self._exponent_unit_map)\n    else:\n        unit = self._exponent_unit_map[unit_place]\n\n    value_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\n\n    if value_str in (\"-0\", \"0\"):\n        stripped = value_str\n    else:\n        stripped = value_str.rstrip(\"0\").rstrip(\".\")\n\n    if not keep_trailing_zeros:\n        value_str = stripped\n    unit_str = unit if stripped not in (\"-0\", \"0\") else self._exponent_unit_map[0]\n    return f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than or equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.__init__","title":"__init__","text":"<pre><code>__init__(value: float, exponent: int = 0) -&gt; None\n</code></pre> <p>Initialize a new quantity.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n    \"\"\"Initialize a new quantity.\n\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\n    self._base_value = value * 10.0**exponent\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(\n    exponent_unit_map: dict[int, str]\n) -&gt; None\n</code></pre> <p>Initialize a new subclass of Quantity.</p> PARAMETER DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n    \"\"\"Initialize a new subclass of Quantity.\n\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n\n    Raises:\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\n    if 0 not in exponent_unit_map:\n        raise ValueError(\"Expected a base unit for the type (for exponent 0)\")\n    cls._exponent_unit_map = exponent_unit_map\n    super().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.__le__","title":"__le__","text":"<pre><code>__le__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than or equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.__mod__","title":"__mod__","text":"<pre><code>__mod__(other: Self) -&gt; Self\n</code></pre> <p>Return the remainder of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The remainder of this quantity and another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __mod__(self, other: Self) -&gt; Self:\n    \"\"\"Return the remainder of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The remainder of this quantity and another.\n    \"\"\"\n    return self._new(self._base_value % other._base_value)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.__mul__","title":"__mul__","text":"<pre><code>__mul__(\n    other: float | Percentage | timedelta,\n) -&gt; Self | Energy\n</code></pre> <p>Return a power or energy from multiplying this power by the given value.</p> PARAMETER DESCRIPTION <code>other</code> <p>The scalar, percentage or duration to multiply by.</p> <p> TYPE: <code>float | Percentage | timedelta</code> </p> RETURNS DESCRIPTION <code>Self | Energy</code> <p>A power or energy.</p> Source code in <code>frequenz/quantities/_power.py</code> <pre><code>def __mul__(self, other: float | Percentage | timedelta, /) -&gt; Self | Energy:\n    \"\"\"Return a power or energy from multiplying this power by the given value.\n\n    Args:\n        other: The scalar, percentage or duration to multiply by.\n\n    Returns:\n        A power or energy.\n    \"\"\"\n    from ._energy import Energy  # pylint: disable=import-outside-toplevel\n    from ._percentage import Percentage  # pylint: disable=import-outside-toplevel\n\n    match other:\n        case float() | Percentage():\n            return super().__mul__(other)\n        case timedelta():\n            return Energy._new(self._base_value * other.total_seconds() / 3600.0)\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> <p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __neg__(self) -&gt; Self:\n    \"\"\"Return the negation of this quantity.\n\n    Returns:\n        The negation of this quantity.\n    \"\"\"\n    negation = type(self).__new__(type(self))\n    negation._base_value = -self._base_value\n    return negation\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.__pos__","title":"__pos__","text":"<pre><code>__pos__() -&gt; Self\n</code></pre> <p>Return this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>This quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __pos__(self) -&gt; Self:\n    \"\"\"Return this quantity.\n\n    Returns:\n        This quantity.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a representation of this quantity.\n\n    Returns:\n        A representation of this quantity.\n    \"\"\"\n    return f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.__round__","title":"__round__","text":"<pre><code>__round__(ndigits: int | None = None) -&gt; Self\n</code></pre> <p>Round this quantity to the given number of digits.</p> PARAMETER DESCRIPTION <code>ndigits</code> <p>The number of digits to round to.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The rounded quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __round__(self, ndigits: int | None = None) -&gt; Self:\n    \"\"\"Round this quantity to the given number of digits.\n\n    Args:\n        ndigits: The number of digits to round to.\n\n    Returns:\n        The rounded quantity.\n    \"\"\"\n    return self._new(round(self._base_value, ndigits))\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this quantity.\n\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\n    return self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Self) -&gt; Self\n</code></pre> <p>Return the difference of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n    \"\"\"Return the difference of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    difference = type(self).__new__(type(self))\n    difference._base_value = self._base_value - other._base_value\n    return difference\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(\n    other: float | Self | Current | Voltage,\n) -&gt; Self | float | Voltage | Current\n</code></pre> <p>Return a current or voltage from dividing this power by the given value.</p> PARAMETER DESCRIPTION <code>other</code> <p>The scalar, power, current or voltage to divide by.</p> <p> TYPE: <code>float | Self | Current | Voltage</code> </p> RETURNS DESCRIPTION <code>Self | float | Voltage | Current</code> <p>A current or voltage from dividing this power by the given value.</p> Source code in <code>frequenz/quantities/_power.py</code> <pre><code>def __truediv__(\n    self, other: float | Self | Current | Voltage, /\n) -&gt; Self | float | Voltage | Current:\n    \"\"\"Return a current or voltage from dividing this power by the given value.\n\n    Args:\n        other: The scalar, power, current or voltage to divide by.\n\n    Returns:\n        A current or voltage from dividing this power by the given value.\n    \"\"\"\n    from ._current import Current  # pylint: disable=import-outside-toplevel\n    from ._voltage import Voltage  # pylint: disable=import-outside-toplevel\n\n    match other:\n        case float():\n            return super().__truediv__(other)\n        case Power():\n            return self._base_value / other._base_value\n        case Current():\n            return Voltage._new(self._base_value / other._base_value)\n        case Voltage():\n            return Current._new(self._base_value / other._base_value)\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.as_kilowatts","title":"as_kilowatts","text":"<pre><code>as_kilowatts() -&gt; float\n</code></pre> <p>Return the power in kilowatts.</p> RETURNS DESCRIPTION <code>float</code> <p>The power in kilowatts.</p> Source code in <code>frequenz/quantities/_power.py</code> <pre><code>def as_kilowatts(self) -&gt; float:\n    \"\"\"Return the power in kilowatts.\n\n    Returns:\n        The power in kilowatts.\n    \"\"\"\n    return self._base_value / 1e3\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.as_megawatts","title":"as_megawatts","text":"<pre><code>as_megawatts() -&gt; float\n</code></pre> <p>Return the power in megawatts.</p> RETURNS DESCRIPTION <code>float</code> <p>The power in megawatts.</p> Source code in <code>frequenz/quantities/_power.py</code> <pre><code>def as_megawatts(self) -&gt; float:\n    \"\"\"Return the power in megawatts.\n\n    Returns:\n        The power in megawatts.\n    \"\"\"\n    return self._base_value / 1e6\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.as_watts","title":"as_watts","text":"<pre><code>as_watts() -&gt; float\n</code></pre> <p>Return the power in watts.</p> RETURNS DESCRIPTION <code>float</code> <p>The power in watts.</p> Source code in <code>frequenz/quantities/_power.py</code> <pre><code>def as_watts(self) -&gt; float:\n    \"\"\"Return the power in watts.\n\n    Returns:\n        The power in watts.\n    \"\"\"\n    return self._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.from_kilowatts","title":"from_kilowatts  <code>classmethod</code>","text":"<pre><code>from_kilowatts(kilowatts: float) -&gt; Self\n</code></pre> <p>Initialize a new power quantity.</p> PARAMETER DESCRIPTION <code>kilowatts</code> <p>The power in kilowatts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new power quantity.</p> Source code in <code>frequenz/quantities/_power.py</code> <pre><code>@classmethod\ndef from_kilowatts(cls, kilowatts: float) -&gt; Self:\n    \"\"\"Initialize a new power quantity.\n\n    Args:\n        kilowatts: The power in kilowatts.\n\n    Returns:\n        A new power quantity.\n    \"\"\"\n    return cls._new(kilowatts, exponent=3)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.from_megawatts","title":"from_megawatts  <code>classmethod</code>","text":"<pre><code>from_megawatts(megawatts: float) -&gt; Self\n</code></pre> <p>Initialize a new power quantity.</p> PARAMETER DESCRIPTION <code>megawatts</code> <p>The power in megawatts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new power quantity.</p> Source code in <code>frequenz/quantities/_power.py</code> <pre><code>@classmethod\ndef from_megawatts(cls, megawatts: float) -&gt; Self:\n    \"\"\"Initialize a new power quantity.\n\n    Args:\n        megawatts: The power in megawatts.\n\n    Returns:\n        A new power quantity.\n    \"\"\"\n    return cls._new(megawatts, exponent=6)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.from_milliwatts","title":"from_milliwatts  <code>classmethod</code>","text":"<pre><code>from_milliwatts(milliwatts: float) -&gt; Self\n</code></pre> <p>Initialize a new power quantity.</p> PARAMETER DESCRIPTION <code>milliwatts</code> <p>The power in milliwatts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new power quantity.</p> Source code in <code>frequenz/quantities/_power.py</code> <pre><code>@classmethod\ndef from_milliwatts(cls, milliwatts: float) -&gt; Self:\n    \"\"\"Initialize a new power quantity.\n\n    Args:\n        milliwatts: The power in milliwatts.\n\n    Returns:\n        A new power quantity.\n    \"\"\"\n    return cls._new(milliwatts, exponent=-3)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(string: str) -&gt; Self\n</code></pre> <p>Return a quantity from a string representation.</p> PARAMETER DESCRIPTION <code>string</code> <p>The string representation of the quantity.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity object with the value given in the string.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the string does not match the expected format.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>@classmethod\ndef from_string(cls, string: str) -&gt; Self:\n    \"\"\"Return a quantity from a string representation.\n\n    Args:\n        string: The string representation of the quantity.\n\n    Returns:\n        A quantity object with the value given in the string.\n\n    Raises:\n        ValueError: If the string does not match the expected format.\n\n    \"\"\"\n    split_string = string.split(\" \")\n\n    if len(split_string) != 2:\n        raise ValueError(\n            f\"Expected a string of the form 'value unit', got {string}\"\n        )\n\n    assert cls._exponent_unit_map is not None\n    exp_map = cls._exponent_unit_map\n\n    for exponent, unit in exp_map.items():\n        if unit == split_string[1]:\n            instance = cls.__new__(cls)\n            try:\n                instance._base_value = float(split_string[0]) * 10**exponent\n            except ValueError as error:\n                raise ValueError(f\"Failed to parse string '{string}'.\") from error\n\n            return instance\n\n    raise ValueError(f\"Unknown unit {split_string[1]}\")\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.from_watts","title":"from_watts  <code>classmethod</code>","text":"<pre><code>from_watts(watts: float) -&gt; Self\n</code></pre> <p>Initialize a new power quantity.</p> PARAMETER DESCRIPTION <code>watts</code> <p>The power in watts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new power quantity.</p> Source code in <code>frequenz/quantities/_power.py</code> <pre><code>@classmethod\ndef from_watts(cls, watts: float) -&gt; Self:\n    \"\"\"Initialize a new power quantity.\n\n    Args:\n        watts: The power in watts.\n\n    Returns:\n        A new power quantity.\n    \"\"\"\n    return cls._new(watts)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.isclose","title":"isclose","text":"<pre><code>isclose(\n    other: Self,\n    rel_tol: float = 1e-09,\n    abs_tol: float = 0.0,\n) -&gt; bool\n</code></pre> <p>Return whether this quantity is close to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n    \"\"\"Return whether this quantity is close to another.\n\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\n    return math.isclose(\n        self._base_value,\n        other._base_value,  # pylint: disable=protected-access\n        rel_tol=rel_tol,\n        abs_tol=abs_tol,\n    )\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.isinf","title":"isinf","text":"<pre><code>isinf() -&gt; bool\n</code></pre> <p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def isinf(self) -&gt; bool:\n    \"\"\"Return whether this quantity is infinite.\n\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\n    return math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.isnan","title":"isnan","text":"<pre><code>isnan() -&gt; bool\n</code></pre> <p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def isnan(self) -&gt; bool:\n    \"\"\"Return whether this quantity is NaN.\n\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\n    return math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Power.zero","title":"zero  <code>classmethod</code>","text":"<pre><code>zero() -&gt; Self\n</code></pre> <p>Return a quantity with value 0.0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.0.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n    \"\"\"Return a quantity with value 0.0.\n\n    Returns:\n        A quantity with value 0.0.\n    \"\"\"\n    _zero = cls._zero_cache.get(cls, None)\n    if _zero is None:\n        _zero = cls.__new__(cls)\n        _zero._base_value = 0.0\n        cls._zero_cache[cls] = _zero\n    assert isinstance(_zero, cls)\n    return _zero\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Quantity","title":"frequenz.quantities.Quantity","text":"<p>A quantity with a unit.</p> <p>Quantities try to behave like float and are also immutable.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>class Quantity:\n    \"\"\"A quantity with a unit.\n\n    Quantities try to behave like float and are also immutable.\n    \"\"\"\n\n    _base_value: float\n    \"\"\"The value of this quantity in the base unit.\"\"\"\n\n    _exponent_unit_map: dict[int, str] | None = None\n    \"\"\"A mapping from the exponent of the base unit to the unit symbol.\n\n    If None, this quantity has no unit.  None is possible only when using the base\n    class.  Sub-classes must define this.\n    \"\"\"\n\n    def __init__(self, value: float, exponent: int = 0) -&gt; None:\n        \"\"\"Initialize a new quantity.\n\n        Args:\n            value: The value of this quantity in a given exponent of the base unit.\n            exponent: The exponent of the base unit the given value is in.\n        \"\"\"\n        self._base_value = value * 10.0**exponent\n\n    @classmethod\n    def _new(cls, value: float, *, exponent: int = 0) -&gt; Self:\n        \"\"\"Instantiate a new quantity subclass instance.\n\n        Args:\n            value: The value of this quantity in a given exponent of the base unit.\n            exponent: The exponent of the base unit the given value is in.\n\n        Returns:\n            A new quantity subclass instance.\n        \"\"\"\n        self = cls.__new__(cls)\n        self._base_value = value * 10.0**exponent\n        return self\n\n    def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n        \"\"\"Initialize a new subclass of Quantity.\n\n        Args:\n            exponent_unit_map: A mapping from the exponent of the base unit to the unit\n                symbol.\n\n        Raises:\n            ValueError: If the given exponent_unit_map does not contain a base unit\n                (exponent 0).\n        \"\"\"\n        if 0 not in exponent_unit_map:\n            raise ValueError(\"Expected a base unit for the type (for exponent 0)\")\n        cls._exponent_unit_map = exponent_unit_map\n        super().__init_subclass__()\n\n    _zero_cache: dict[type, Quantity] = {}\n    \"\"\"Cache for zero singletons.\n\n    This is a workaround for mypy getting confused when using @functools.cache and\n    @classmethod combined with returning Self. It believes the resulting type of this\n    method is Self and complains that members of the actual class don't exist in Self,\n    so we need to implement the cache ourselves.\n    \"\"\"\n\n    @classmethod\n    def zero(cls) -&gt; Self:\n        \"\"\"Return a quantity with value 0.0.\n\n        Returns:\n            A quantity with value 0.0.\n        \"\"\"\n        _zero = cls._zero_cache.get(cls, None)\n        if _zero is None:\n            _zero = cls.__new__(cls)\n            _zero._base_value = 0.0\n            cls._zero_cache[cls] = _zero\n        assert isinstance(_zero, cls)\n        return _zero\n\n    @classmethod\n    def from_string(cls, string: str) -&gt; Self:\n        \"\"\"Return a quantity from a string representation.\n\n        Args:\n            string: The string representation of the quantity.\n\n        Returns:\n            A quantity object with the value given in the string.\n\n        Raises:\n            ValueError: If the string does not match the expected format.\n\n        \"\"\"\n        split_string = string.split(\" \")\n\n        if len(split_string) != 2:\n            raise ValueError(\n                f\"Expected a string of the form 'value unit', got {string}\"\n            )\n\n        assert cls._exponent_unit_map is not None\n        exp_map = cls._exponent_unit_map\n\n        for exponent, unit in exp_map.items():\n            if unit == split_string[1]:\n                instance = cls.__new__(cls)\n                try:\n                    instance._base_value = float(split_string[0]) * 10**exponent\n                except ValueError as error:\n                    raise ValueError(f\"Failed to parse string '{string}'.\") from error\n\n                return instance\n\n        raise ValueError(f\"Unknown unit {split_string[1]}\")\n\n    @property\n    def base_value(self) -&gt; float:\n        \"\"\"Return the value of this quantity in the base unit.\n\n        Returns:\n            The value of this quantity in the base unit.\n        \"\"\"\n        return self._base_value\n\n    def __round__(self, ndigits: int | None = None) -&gt; Self:\n        \"\"\"Round this quantity to the given number of digits.\n\n        Args:\n            ndigits: The number of digits to round to.\n\n        Returns:\n            The rounded quantity.\n        \"\"\"\n        return self._new(round(self._base_value, ndigits))\n\n    def __pos__(self) -&gt; Self:\n        \"\"\"Return this quantity.\n\n        Returns:\n            This quantity.\n        \"\"\"\n        return self\n\n    def __mod__(self, other: Self) -&gt; Self:\n        \"\"\"Return the remainder of this quantity and another.\n\n        Args:\n            other: The other quantity.\n\n        Returns:\n            The remainder of this quantity and another.\n        \"\"\"\n        return self._new(self._base_value % other._base_value)\n\n    @property\n    def base_unit(self) -&gt; str | None:\n        \"\"\"Return the base unit of this quantity.\n\n        None if this quantity has no unit.\n\n        Returns:\n            The base unit of this quantity.\n        \"\"\"\n        if not self._exponent_unit_map:\n            return None\n        return self._exponent_unit_map[0]\n\n    def isnan(self) -&gt; bool:\n        \"\"\"Return whether this quantity is NaN.\n\n        Returns:\n            Whether this quantity is NaN.\n        \"\"\"\n        return math.isnan(self._base_value)\n\n    def isinf(self) -&gt; bool:\n        \"\"\"Return whether this quantity is infinite.\n\n        Returns:\n            Whether this quantity is infinite.\n        \"\"\"\n        return math.isinf(self._base_value)\n\n    def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n        \"\"\"Return whether this quantity is close to another.\n\n        Args:\n            other: The quantity to compare to.\n            rel_tol: The relative tolerance.\n            abs_tol: The absolute tolerance.\n\n        Returns:\n            Whether this quantity is close to another.\n        \"\"\"\n        return math.isclose(\n            self._base_value,\n            other._base_value,  # pylint: disable=protected-access\n            rel_tol=rel_tol,\n            abs_tol=abs_tol,\n        )\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a representation of this quantity.\n\n        Returns:\n            A representation of this quantity.\n        \"\"\"\n        return f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of this quantity.\n\n        Returns:\n            A string representation of this quantity.\n        \"\"\"\n        return self.__format__(\"\")\n\n    # pylint: disable=too-many-branches\n    def __format__(self, __format_spec: str) -&gt; str:\n        \"\"\"Return a formatted string representation of this quantity.\n\n        If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n        trailing zeros will be omitted.  If no precision is given, the default is 3.\n\n        The returned string will use the unit that will result in the maximum precision,\n        based on the magnitude of the value.\n\n        Example:\n            ```python\n            from frequenz.quantities import Current\n            c = Current.from_amperes(0.2345)\n            assert f\"{c:.2}\" == \"234.5 mA\"\n            c = Current.from_amperes(1.2345)\n            assert f\"{c:.2}\" == \"1.23 A\"\n            c = Current.from_milliamperes(1.2345)\n            assert f\"{c:.6}\" == \"1.2345 mA\"\n            ```\n\n        Args:\n            __format_spec: The format specifier.\n\n        Returns:\n            A string representation of this quantity.\n\n        Raises:\n            ValueError: If the given format specifier is invalid.\n        \"\"\"\n        keep_trailing_zeros = False\n        if __format_spec != \"\":\n            fspec_parts = __format_spec.split(\".\")\n            if (\n                len(fspec_parts) != 2\n                or fspec_parts[0] not in (\"\", \"0\")\n                or not fspec_parts[1].isdigit()\n            ):\n                raise ValueError(\n                    \"Invalid format specifier. Must be empty or `[0].{precision}`\"\n                )\n            if fspec_parts[0] == \"0\":\n                keep_trailing_zeros = True\n            precision = int(fspec_parts[1])\n        else:\n            precision = 3\n        if not self._exponent_unit_map:\n            return f\"{self._base_value:.{precision}f}\"\n\n        if math.isinf(self._base_value) or math.isnan(self._base_value):\n            return f\"{self._base_value} {self._exponent_unit_map[0]}\"\n\n        if abs_value := abs(self._base_value):\n            precision_pow = 10 ** (precision)\n            # Prevent numbers like 999.999999 being rendered as 1000 V\n            # instead of 1 kV.\n            # This could happen because the str formatting function does\n            # rounding as well.\n            # This is an imperfect solution that works for _most_ cases.\n            # isclose parameters were chosen according to the observed cases\n            if math.isclose(abs_value, precision_pow, abs_tol=1e-4, rel_tol=0.01):\n                # If the value is close to the precision, round it\n                exponent = math.ceil(math.log10(precision_pow))\n            else:\n                exponent = math.floor(math.log10(abs_value))\n        else:\n            exponent = 0\n\n        unit_place = exponent - exponent % 3\n        if unit_place &lt; min(self._exponent_unit_map):\n            unit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\n            unit_place = min(self._exponent_unit_map)\n        elif unit_place &gt; max(self._exponent_unit_map):\n            unit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\n            unit_place = max(self._exponent_unit_map)\n        else:\n            unit = self._exponent_unit_map[unit_place]\n\n        value_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\n\n        if value_str in (\"-0\", \"0\"):\n            stripped = value_str\n        else:\n            stripped = value_str.rstrip(\"0\").rstrip(\".\")\n\n        if not keep_trailing_zeros:\n            value_str = stripped\n        unit_str = unit if stripped not in (\"-0\", \"0\") else self._exponent_unit_map[0]\n        return f\"{value_str} {unit_str}\"\n\n    def __add__(self, other: Self) -&gt; Self:\n        \"\"\"Return the sum of this quantity and another.\n\n        Args:\n            other: The other quantity.\n\n        Returns:\n            The sum of this quantity and another.\n        \"\"\"\n        if not type(other) is type(self):\n            return NotImplemented\n        summe = type(self).__new__(type(self))\n        summe._base_value = self._base_value + other._base_value\n        return summe\n\n    def __sub__(self, other: Self) -&gt; Self:\n        \"\"\"Return the difference of this quantity and another.\n\n        Args:\n            other: The other quantity.\n\n        Returns:\n            The difference of this quantity and another.\n        \"\"\"\n        if not type(other) is type(self):\n            return NotImplemented\n        difference = type(self).__new__(type(self))\n        difference._base_value = self._base_value - other._base_value\n        return difference\n\n    @overload\n    def __mul__(self, scalar: float, /) -&gt; Self:\n        \"\"\"Scale this quantity by a scalar.\n\n        Args:\n            scalar: The scalar by which to scale this quantity.\n\n        Returns:\n            The scaled quantity.\n        \"\"\"\n\n    @overload\n    def __mul__(self, percent: Percentage, /) -&gt; Self:\n        \"\"\"Scale this quantity by a percentage.\n\n        Args:\n            percent: The percentage by which to scale this quantity.\n\n        Returns:\n            The scaled quantity.\n        \"\"\"\n\n    def __mul__(self, value: float | Percentage, /) -&gt; Self:\n        \"\"\"Scale this quantity by a scalar or percentage.\n\n        Args:\n            value: The scalar or percentage by which to scale this quantity.\n\n        Returns:\n            The scaled quantity.\n        \"\"\"\n        from ._percentage import Percentage  # pylint: disable=import-outside-toplevel\n\n        match value:\n            case float():\n                return type(self)._new(self._base_value * value)\n            case Percentage():\n                return type(self)._new(self._base_value * value.as_fraction())\n            case _:\n                return NotImplemented\n\n    @overload\n    def __truediv__(self, other: float, /) -&gt; Self:\n        \"\"\"Divide this quantity by a scalar.\n\n        Args:\n            other: The scalar or percentage to divide this quantity by.\n\n        Returns:\n            The divided quantity.\n        \"\"\"\n\n    @overload\n    def __truediv__(self, other: Self, /) -&gt; float:\n        \"\"\"Return the ratio of this quantity to another.\n\n        Args:\n            other: The other quantity.\n\n        Returns:\n            The ratio of this quantity to another.\n        \"\"\"\n\n    def __truediv__(self, value: float | Self, /) -&gt; Self | float:\n        \"\"\"Divide this quantity by a scalar or another quantity.\n\n        Args:\n            value: The scalar or quantity to divide this quantity by.\n\n        Returns:\n            The divided quantity or the ratio of this quantity to another.\n        \"\"\"\n        match value:\n            case float():\n                return type(self)._new(self._base_value / value)\n            case Quantity() if type(value) is type(self):\n                return self._base_value / value._base_value\n            case _:\n                return NotImplemented\n\n    def __gt__(self, other: Self) -&gt; bool:\n        \"\"\"Return whether this quantity is greater than another.\n\n        Args:\n            other: The other quantity.\n\n        Returns:\n            Whether this quantity is greater than another.\n        \"\"\"\n        if not type(other) is type(self):\n            return NotImplemented\n        return self._base_value &gt; other._base_value\n\n    def __ge__(self, other: Self) -&gt; bool:\n        \"\"\"Return whether this quantity is greater than or equal to another.\n\n        Args:\n            other: The other quantity.\n\n        Returns:\n            Whether this quantity is greater than or equal to another.\n        \"\"\"\n        if not type(other) is type(self):\n            return NotImplemented\n        return self._base_value &gt;= other._base_value\n\n    def __lt__(self, other: Self) -&gt; bool:\n        \"\"\"Return whether this quantity is less than another.\n\n        Args:\n            other: The other quantity.\n\n        Returns:\n            Whether this quantity is less than another.\n        \"\"\"\n        if not type(other) is type(self):\n            return NotImplemented\n        return self._base_value &lt; other._base_value\n\n    def __le__(self, other: Self) -&gt; bool:\n        \"\"\"Return whether this quantity is less than or equal to another.\n\n        Args:\n            other: The other quantity.\n\n        Returns:\n            Whether this quantity is less than or equal to another.\n        \"\"\"\n        if not type(other) is type(self):\n            return NotImplemented\n        return self._base_value &lt;= other._base_value\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Return whether this quantity is equal to another.\n\n        Args:\n            other: The other quantity.\n\n        Returns:\n            Whether this quantity is equal to another.\n        \"\"\"\n        if not type(other) is type(self):\n            return NotImplemented\n        # The above check ensures that both quantities are the exact same type, because\n        # `isinstance` returns true for subclasses and superclasses.  But the above check\n        # doesn't help mypy identify the type of other,  so the below line is necessary.\n        assert isinstance(other, self.__class__)\n        return self._base_value == other._base_value\n\n    def __neg__(self) -&gt; Self:\n        \"\"\"Return the negation of this quantity.\n\n        Returns:\n            The negation of this quantity.\n        \"\"\"\n        negation = type(self).__new__(type(self))\n        negation._base_value = -self._base_value\n        return negation\n\n    def __abs__(self) -&gt; Self:\n        \"\"\"Return the absolute value of this quantity.\n\n        Returns:\n            The absolute value of this quantity.\n        \"\"\"\n        absolute = type(self).__new__(type(self))\n        absolute._base_value = abs(self._base_value)\n        return absolute\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Quantity-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/quantities/#frequenz.quantities.Quantity.base_unit","title":"base_unit  <code>property</code>","text":"<pre><code>base_unit: str | None\n</code></pre> <p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Quantity.base_value","title":"base_value  <code>property</code>","text":"<pre><code>base_value: float\n</code></pre> <p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Quantity-functions","title":"Functions","text":""},{"location":"reference/frequenz/quantities/#frequenz.quantities.Quantity.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> <p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __abs__(self) -&gt; Self:\n    \"\"\"Return the absolute value of this quantity.\n\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\n    absolute = type(self).__new__(type(self))\n    absolute._base_value = abs(self._base_value)\n    return absolute\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Quantity.__add__","title":"__add__","text":"<pre><code>__add__(other: Self) -&gt; Self\n</code></pre> <p>Return the sum of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n    \"\"\"Return the sum of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    summe = type(self).__new__(type(self))\n    summe._base_value = self._base_value + other._base_value\n    return summe\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Quantity.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether this quantity is equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Return whether this quantity is equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    # The above check ensures that both quantities are the exact same type, because\n    # `isinstance` returns true for subclasses and superclasses.  But the above check\n    # doesn't help mypy identify the type of other,  so the below line is necessary.\n    assert isinstance(other, self.__class__)\n    return self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Quantity.__format__","title":"__format__","text":"<pre><code>__format__(__format_spec: str) -&gt; str\n</code></pre> <p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.quantities import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n    \"\"\"Return a formatted string representation of this quantity.\n\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n\n    Example:\n        ```python\n        from frequenz.quantities import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n\n    Args:\n        __format_spec: The format specifier.\n\n    Returns:\n        A string representation of this quantity.\n\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\n    keep_trailing_zeros = False\n    if __format_spec != \"\":\n        fspec_parts = __format_spec.split(\".\")\n        if (\n            len(fspec_parts) != 2\n            or fspec_parts[0] not in (\"\", \"0\")\n            or not fspec_parts[1].isdigit()\n        ):\n            raise ValueError(\n                \"Invalid format specifier. Must be empty or `[0].{precision}`\"\n            )\n        if fspec_parts[0] == \"0\":\n            keep_trailing_zeros = True\n        precision = int(fspec_parts[1])\n    else:\n        precision = 3\n    if not self._exponent_unit_map:\n        return f\"{self._base_value:.{precision}f}\"\n\n    if math.isinf(self._base_value) or math.isnan(self._base_value):\n        return f\"{self._base_value} {self._exponent_unit_map[0]}\"\n\n    if abs_value := abs(self._base_value):\n        precision_pow = 10 ** (precision)\n        # Prevent numbers like 999.999999 being rendered as 1000 V\n        # instead of 1 kV.\n        # This could happen because the str formatting function does\n        # rounding as well.\n        # This is an imperfect solution that works for _most_ cases.\n        # isclose parameters were chosen according to the observed cases\n        if math.isclose(abs_value, precision_pow, abs_tol=1e-4, rel_tol=0.01):\n            # If the value is close to the precision, round it\n            exponent = math.ceil(math.log10(precision_pow))\n        else:\n            exponent = math.floor(math.log10(abs_value))\n    else:\n        exponent = 0\n\n    unit_place = exponent - exponent % 3\n    if unit_place &lt; min(self._exponent_unit_map):\n        unit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\n        unit_place = min(self._exponent_unit_map)\n    elif unit_place &gt; max(self._exponent_unit_map):\n        unit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\n        unit_place = max(self._exponent_unit_map)\n    else:\n        unit = self._exponent_unit_map[unit_place]\n\n    value_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\n\n    if value_str in (\"-0\", \"0\"):\n        stripped = value_str\n    else:\n        stripped = value_str.rstrip(\"0\").rstrip(\".\")\n\n    if not keep_trailing_zeros:\n        value_str = stripped\n    unit_str = unit if stripped not in (\"-0\", \"0\") else self._exponent_unit_map[0]\n    return f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Quantity.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than or equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Quantity.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Quantity.__init__","title":"__init__","text":"<pre><code>__init__(value: float, exponent: int = 0) -&gt; None\n</code></pre> <p>Initialize a new quantity.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n    \"\"\"Initialize a new quantity.\n\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\n    self._base_value = value * 10.0**exponent\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Quantity.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(\n    exponent_unit_map: dict[int, str]\n) -&gt; None\n</code></pre> <p>Initialize a new subclass of Quantity.</p> PARAMETER DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n    \"\"\"Initialize a new subclass of Quantity.\n\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n\n    Raises:\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\n    if 0 not in exponent_unit_map:\n        raise ValueError(\"Expected a base unit for the type (for exponent 0)\")\n    cls._exponent_unit_map = exponent_unit_map\n    super().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Quantity.__le__","title":"__le__","text":"<pre><code>__le__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than or equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Quantity.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Quantity.__mod__","title":"__mod__","text":"<pre><code>__mod__(other: Self) -&gt; Self\n</code></pre> <p>Return the remainder of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The remainder of this quantity and another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __mod__(self, other: Self) -&gt; Self:\n    \"\"\"Return the remainder of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The remainder of this quantity and another.\n    \"\"\"\n    return self._new(self._base_value % other._base_value)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Quantity.__mul__","title":"__mul__","text":"<pre><code>__mul__(value: float | Percentage) -&gt; Self\n</code></pre> <p>Scale this quantity by a scalar or percentage.</p> PARAMETER DESCRIPTION <code>value</code> <p>The scalar or percentage by which to scale this quantity.</p> <p> TYPE: <code>float | Percentage</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The scaled quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __mul__(self, value: float | Percentage, /) -&gt; Self:\n    \"\"\"Scale this quantity by a scalar or percentage.\n\n    Args:\n        value: The scalar or percentage by which to scale this quantity.\n\n    Returns:\n        The scaled quantity.\n    \"\"\"\n    from ._percentage import Percentage  # pylint: disable=import-outside-toplevel\n\n    match value:\n        case float():\n            return type(self)._new(self._base_value * value)\n        case Percentage():\n            return type(self)._new(self._base_value * value.as_fraction())\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Quantity.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> <p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __neg__(self) -&gt; Self:\n    \"\"\"Return the negation of this quantity.\n\n    Returns:\n        The negation of this quantity.\n    \"\"\"\n    negation = type(self).__new__(type(self))\n    negation._base_value = -self._base_value\n    return negation\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Quantity.__pos__","title":"__pos__","text":"<pre><code>__pos__() -&gt; Self\n</code></pre> <p>Return this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>This quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __pos__(self) -&gt; Self:\n    \"\"\"Return this quantity.\n\n    Returns:\n        This quantity.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Quantity.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a representation of this quantity.\n\n    Returns:\n        A representation of this quantity.\n    \"\"\"\n    return f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Quantity.__round__","title":"__round__","text":"<pre><code>__round__(ndigits: int | None = None) -&gt; Self\n</code></pre> <p>Round this quantity to the given number of digits.</p> PARAMETER DESCRIPTION <code>ndigits</code> <p>The number of digits to round to.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The rounded quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __round__(self, ndigits: int | None = None) -&gt; Self:\n    \"\"\"Round this quantity to the given number of digits.\n\n    Args:\n        ndigits: The number of digits to round to.\n\n    Returns:\n        The rounded quantity.\n    \"\"\"\n    return self._new(round(self._base_value, ndigits))\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Quantity.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this quantity.\n\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\n    return self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Quantity.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Self) -&gt; Self\n</code></pre> <p>Return the difference of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n    \"\"\"Return the difference of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    difference = type(self).__new__(type(self))\n    difference._base_value = self._base_value - other._base_value\n    return difference\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Quantity.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(value: float | Self) -&gt; Self | float\n</code></pre> <p>Divide this quantity by a scalar or another quantity.</p> PARAMETER DESCRIPTION <code>value</code> <p>The scalar or quantity to divide this quantity by.</p> <p> TYPE: <code>float | Self</code> </p> RETURNS DESCRIPTION <code>Self | float</code> <p>The divided quantity or the ratio of this quantity to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __truediv__(self, value: float | Self, /) -&gt; Self | float:\n    \"\"\"Divide this quantity by a scalar or another quantity.\n\n    Args:\n        value: The scalar or quantity to divide this quantity by.\n\n    Returns:\n        The divided quantity or the ratio of this quantity to another.\n    \"\"\"\n    match value:\n        case float():\n            return type(self)._new(self._base_value / value)\n        case Quantity() if type(value) is type(self):\n            return self._base_value / value._base_value\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Quantity.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(string: str) -&gt; Self\n</code></pre> <p>Return a quantity from a string representation.</p> PARAMETER DESCRIPTION <code>string</code> <p>The string representation of the quantity.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity object with the value given in the string.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the string does not match the expected format.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>@classmethod\ndef from_string(cls, string: str) -&gt; Self:\n    \"\"\"Return a quantity from a string representation.\n\n    Args:\n        string: The string representation of the quantity.\n\n    Returns:\n        A quantity object with the value given in the string.\n\n    Raises:\n        ValueError: If the string does not match the expected format.\n\n    \"\"\"\n    split_string = string.split(\" \")\n\n    if len(split_string) != 2:\n        raise ValueError(\n            f\"Expected a string of the form 'value unit', got {string}\"\n        )\n\n    assert cls._exponent_unit_map is not None\n    exp_map = cls._exponent_unit_map\n\n    for exponent, unit in exp_map.items():\n        if unit == split_string[1]:\n            instance = cls.__new__(cls)\n            try:\n                instance._base_value = float(split_string[0]) * 10**exponent\n            except ValueError as error:\n                raise ValueError(f\"Failed to parse string '{string}'.\") from error\n\n            return instance\n\n    raise ValueError(f\"Unknown unit {split_string[1]}\")\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Quantity.isclose","title":"isclose","text":"<pre><code>isclose(\n    other: Self,\n    rel_tol: float = 1e-09,\n    abs_tol: float = 0.0,\n) -&gt; bool\n</code></pre> <p>Return whether this quantity is close to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n    \"\"\"Return whether this quantity is close to another.\n\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\n    return math.isclose(\n        self._base_value,\n        other._base_value,  # pylint: disable=protected-access\n        rel_tol=rel_tol,\n        abs_tol=abs_tol,\n    )\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Quantity.isinf","title":"isinf","text":"<pre><code>isinf() -&gt; bool\n</code></pre> <p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def isinf(self) -&gt; bool:\n    \"\"\"Return whether this quantity is infinite.\n\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\n    return math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Quantity.isnan","title":"isnan","text":"<pre><code>isnan() -&gt; bool\n</code></pre> <p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def isnan(self) -&gt; bool:\n    \"\"\"Return whether this quantity is NaN.\n\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\n    return math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Quantity.zero","title":"zero  <code>classmethod</code>","text":"<pre><code>zero() -&gt; Self\n</code></pre> <p>Return a quantity with value 0.0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.0.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n    \"\"\"Return a quantity with value 0.0.\n\n    Returns:\n        A quantity with value 0.0.\n    \"\"\"\n    _zero = cls._zero_cache.get(cls, None)\n    if _zero is None:\n        _zero = cls.__new__(cls)\n        _zero._base_value = 0.0\n        cls._zero_cache[cls] = _zero\n    assert isinstance(_zero, cls)\n    return _zero\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Temperature","title":"frequenz.quantities.Temperature","text":"<p>               Bases: <code>Quantity</code></p> <p>A temperature quantity (in degrees Celsius).</p> Source code in <code>frequenz/quantities/_temperature.py</code> <pre><code>class Temperature(\n    Quantity,\n    metaclass=NoDefaultConstructible,\n    exponent_unit_map={\n        0: \"\u00b0C\",\n    },\n):\n    \"\"\"A temperature quantity (in degrees Celsius).\"\"\"\n\n    @classmethod\n    def from_celsius(cls, value: float) -&gt; Self:\n        \"\"\"Initialize a new temperature quantity.\n\n        Args:\n            value: The temperature in degrees Celsius.\n\n        Returns:\n            A new temperature quantity.\n        \"\"\"\n        return cls._new(value)\n\n    def as_celsius(self) -&gt; float:\n        \"\"\"Return the temperature in degrees Celsius.\n\n        Returns:\n            The temperature in degrees Celsius.\n        \"\"\"\n        return self._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Temperature-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/quantities/#frequenz.quantities.Temperature.base_unit","title":"base_unit  <code>property</code>","text":"<pre><code>base_unit: str | None\n</code></pre> <p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Temperature.base_value","title":"base_value  <code>property</code>","text":"<pre><code>base_value: float\n</code></pre> <p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Temperature-functions","title":"Functions","text":""},{"location":"reference/frequenz/quantities/#frequenz.quantities.Temperature.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> <p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __abs__(self) -&gt; Self:\n    \"\"\"Return the absolute value of this quantity.\n\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\n    absolute = type(self).__new__(type(self))\n    absolute._base_value = abs(self._base_value)\n    return absolute\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Temperature.__add__","title":"__add__","text":"<pre><code>__add__(other: Self) -&gt; Self\n</code></pre> <p>Return the sum of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n    \"\"\"Return the sum of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    summe = type(self).__new__(type(self))\n    summe._base_value = self._base_value + other._base_value\n    return summe\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Temperature.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether this quantity is equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Return whether this quantity is equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    # The above check ensures that both quantities are the exact same type, because\n    # `isinstance` returns true for subclasses and superclasses.  But the above check\n    # doesn't help mypy identify the type of other,  so the below line is necessary.\n    assert isinstance(other, self.__class__)\n    return self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Temperature.__format__","title":"__format__","text":"<pre><code>__format__(__format_spec: str) -&gt; str\n</code></pre> <p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.quantities import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n    \"\"\"Return a formatted string representation of this quantity.\n\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n\n    Example:\n        ```python\n        from frequenz.quantities import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n\n    Args:\n        __format_spec: The format specifier.\n\n    Returns:\n        A string representation of this quantity.\n\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\n    keep_trailing_zeros = False\n    if __format_spec != \"\":\n        fspec_parts = __format_spec.split(\".\")\n        if (\n            len(fspec_parts) != 2\n            or fspec_parts[0] not in (\"\", \"0\")\n            or not fspec_parts[1].isdigit()\n        ):\n            raise ValueError(\n                \"Invalid format specifier. Must be empty or `[0].{precision}`\"\n            )\n        if fspec_parts[0] == \"0\":\n            keep_trailing_zeros = True\n        precision = int(fspec_parts[1])\n    else:\n        precision = 3\n    if not self._exponent_unit_map:\n        return f\"{self._base_value:.{precision}f}\"\n\n    if math.isinf(self._base_value) or math.isnan(self._base_value):\n        return f\"{self._base_value} {self._exponent_unit_map[0]}\"\n\n    if abs_value := abs(self._base_value):\n        precision_pow = 10 ** (precision)\n        # Prevent numbers like 999.999999 being rendered as 1000 V\n        # instead of 1 kV.\n        # This could happen because the str formatting function does\n        # rounding as well.\n        # This is an imperfect solution that works for _most_ cases.\n        # isclose parameters were chosen according to the observed cases\n        if math.isclose(abs_value, precision_pow, abs_tol=1e-4, rel_tol=0.01):\n            # If the value is close to the precision, round it\n            exponent = math.ceil(math.log10(precision_pow))\n        else:\n            exponent = math.floor(math.log10(abs_value))\n    else:\n        exponent = 0\n\n    unit_place = exponent - exponent % 3\n    if unit_place &lt; min(self._exponent_unit_map):\n        unit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\n        unit_place = min(self._exponent_unit_map)\n    elif unit_place &gt; max(self._exponent_unit_map):\n        unit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\n        unit_place = max(self._exponent_unit_map)\n    else:\n        unit = self._exponent_unit_map[unit_place]\n\n    value_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\n\n    if value_str in (\"-0\", \"0\"):\n        stripped = value_str\n    else:\n        stripped = value_str.rstrip(\"0\").rstrip(\".\")\n\n    if not keep_trailing_zeros:\n        value_str = stripped\n    unit_str = unit if stripped not in (\"-0\", \"0\") else self._exponent_unit_map[0]\n    return f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Temperature.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than or equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Temperature.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Temperature.__init__","title":"__init__","text":"<pre><code>__init__(value: float, exponent: int = 0) -&gt; None\n</code></pre> <p>Initialize a new quantity.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n    \"\"\"Initialize a new quantity.\n\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\n    self._base_value = value * 10.0**exponent\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Temperature.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(\n    exponent_unit_map: dict[int, str]\n) -&gt; None\n</code></pre> <p>Initialize a new subclass of Quantity.</p> PARAMETER DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n    \"\"\"Initialize a new subclass of Quantity.\n\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n\n    Raises:\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\n    if 0 not in exponent_unit_map:\n        raise ValueError(\"Expected a base unit for the type (for exponent 0)\")\n    cls._exponent_unit_map = exponent_unit_map\n    super().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Temperature.__le__","title":"__le__","text":"<pre><code>__le__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than or equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Temperature.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Temperature.__mod__","title":"__mod__","text":"<pre><code>__mod__(other: Self) -&gt; Self\n</code></pre> <p>Return the remainder of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The remainder of this quantity and another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __mod__(self, other: Self) -&gt; Self:\n    \"\"\"Return the remainder of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The remainder of this quantity and another.\n    \"\"\"\n    return self._new(self._base_value % other._base_value)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Temperature.__mul__","title":"__mul__","text":"<pre><code>__mul__(value: float | Percentage) -&gt; Self\n</code></pre> <p>Scale this quantity by a scalar or percentage.</p> PARAMETER DESCRIPTION <code>value</code> <p>The scalar or percentage by which to scale this quantity.</p> <p> TYPE: <code>float | Percentage</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The scaled quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __mul__(self, value: float | Percentage, /) -&gt; Self:\n    \"\"\"Scale this quantity by a scalar or percentage.\n\n    Args:\n        value: The scalar or percentage by which to scale this quantity.\n\n    Returns:\n        The scaled quantity.\n    \"\"\"\n    from ._percentage import Percentage  # pylint: disable=import-outside-toplevel\n\n    match value:\n        case float():\n            return type(self)._new(self._base_value * value)\n        case Percentage():\n            return type(self)._new(self._base_value * value.as_fraction())\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Temperature.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> <p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __neg__(self) -&gt; Self:\n    \"\"\"Return the negation of this quantity.\n\n    Returns:\n        The negation of this quantity.\n    \"\"\"\n    negation = type(self).__new__(type(self))\n    negation._base_value = -self._base_value\n    return negation\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Temperature.__pos__","title":"__pos__","text":"<pre><code>__pos__() -&gt; Self\n</code></pre> <p>Return this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>This quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __pos__(self) -&gt; Self:\n    \"\"\"Return this quantity.\n\n    Returns:\n        This quantity.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Temperature.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a representation of this quantity.\n\n    Returns:\n        A representation of this quantity.\n    \"\"\"\n    return f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Temperature.__round__","title":"__round__","text":"<pre><code>__round__(ndigits: int | None = None) -&gt; Self\n</code></pre> <p>Round this quantity to the given number of digits.</p> PARAMETER DESCRIPTION <code>ndigits</code> <p>The number of digits to round to.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The rounded quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __round__(self, ndigits: int | None = None) -&gt; Self:\n    \"\"\"Round this quantity to the given number of digits.\n\n    Args:\n        ndigits: The number of digits to round to.\n\n    Returns:\n        The rounded quantity.\n    \"\"\"\n    return self._new(round(self._base_value, ndigits))\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Temperature.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this quantity.\n\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\n    return self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Temperature.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Self) -&gt; Self\n</code></pre> <p>Return the difference of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n    \"\"\"Return the difference of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    difference = type(self).__new__(type(self))\n    difference._base_value = self._base_value - other._base_value\n    return difference\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Temperature.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(value: float | Self) -&gt; Self | float\n</code></pre> <p>Divide this quantity by a scalar or another quantity.</p> PARAMETER DESCRIPTION <code>value</code> <p>The scalar or quantity to divide this quantity by.</p> <p> TYPE: <code>float | Self</code> </p> RETURNS DESCRIPTION <code>Self | float</code> <p>The divided quantity or the ratio of this quantity to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __truediv__(self, value: float | Self, /) -&gt; Self | float:\n    \"\"\"Divide this quantity by a scalar or another quantity.\n\n    Args:\n        value: The scalar or quantity to divide this quantity by.\n\n    Returns:\n        The divided quantity or the ratio of this quantity to another.\n    \"\"\"\n    match value:\n        case float():\n            return type(self)._new(self._base_value / value)\n        case Quantity() if type(value) is type(self):\n            return self._base_value / value._base_value\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Temperature.as_celsius","title":"as_celsius","text":"<pre><code>as_celsius() -&gt; float\n</code></pre> <p>Return the temperature in degrees Celsius.</p> RETURNS DESCRIPTION <code>float</code> <p>The temperature in degrees Celsius.</p> Source code in <code>frequenz/quantities/_temperature.py</code> <pre><code>def as_celsius(self) -&gt; float:\n    \"\"\"Return the temperature in degrees Celsius.\n\n    Returns:\n        The temperature in degrees Celsius.\n    \"\"\"\n    return self._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Temperature.from_celsius","title":"from_celsius  <code>classmethod</code>","text":"<pre><code>from_celsius(value: float) -&gt; Self\n</code></pre> <p>Initialize a new temperature quantity.</p> PARAMETER DESCRIPTION <code>value</code> <p>The temperature in degrees Celsius.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new temperature quantity.</p> Source code in <code>frequenz/quantities/_temperature.py</code> <pre><code>@classmethod\ndef from_celsius(cls, value: float) -&gt; Self:\n    \"\"\"Initialize a new temperature quantity.\n\n    Args:\n        value: The temperature in degrees Celsius.\n\n    Returns:\n        A new temperature quantity.\n    \"\"\"\n    return cls._new(value)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Temperature.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(string: str) -&gt; Self\n</code></pre> <p>Return a quantity from a string representation.</p> PARAMETER DESCRIPTION <code>string</code> <p>The string representation of the quantity.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity object with the value given in the string.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the string does not match the expected format.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>@classmethod\ndef from_string(cls, string: str) -&gt; Self:\n    \"\"\"Return a quantity from a string representation.\n\n    Args:\n        string: The string representation of the quantity.\n\n    Returns:\n        A quantity object with the value given in the string.\n\n    Raises:\n        ValueError: If the string does not match the expected format.\n\n    \"\"\"\n    split_string = string.split(\" \")\n\n    if len(split_string) != 2:\n        raise ValueError(\n            f\"Expected a string of the form 'value unit', got {string}\"\n        )\n\n    assert cls._exponent_unit_map is not None\n    exp_map = cls._exponent_unit_map\n\n    for exponent, unit in exp_map.items():\n        if unit == split_string[1]:\n            instance = cls.__new__(cls)\n            try:\n                instance._base_value = float(split_string[0]) * 10**exponent\n            except ValueError as error:\n                raise ValueError(f\"Failed to parse string '{string}'.\") from error\n\n            return instance\n\n    raise ValueError(f\"Unknown unit {split_string[1]}\")\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Temperature.isclose","title":"isclose","text":"<pre><code>isclose(\n    other: Self,\n    rel_tol: float = 1e-09,\n    abs_tol: float = 0.0,\n) -&gt; bool\n</code></pre> <p>Return whether this quantity is close to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n    \"\"\"Return whether this quantity is close to another.\n\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\n    return math.isclose(\n        self._base_value,\n        other._base_value,  # pylint: disable=protected-access\n        rel_tol=rel_tol,\n        abs_tol=abs_tol,\n    )\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Temperature.isinf","title":"isinf","text":"<pre><code>isinf() -&gt; bool\n</code></pre> <p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def isinf(self) -&gt; bool:\n    \"\"\"Return whether this quantity is infinite.\n\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\n    return math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Temperature.isnan","title":"isnan","text":"<pre><code>isnan() -&gt; bool\n</code></pre> <p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def isnan(self) -&gt; bool:\n    \"\"\"Return whether this quantity is NaN.\n\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\n    return math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Temperature.zero","title":"zero  <code>classmethod</code>","text":"<pre><code>zero() -&gt; Self\n</code></pre> <p>Return a quantity with value 0.0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.0.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n    \"\"\"Return a quantity with value 0.0.\n\n    Returns:\n        A quantity with value 0.0.\n    \"\"\"\n    _zero = cls._zero_cache.get(cls, None)\n    if _zero is None:\n        _zero = cls.__new__(cls)\n        _zero._base_value = 0.0\n        cls._zero_cache[cls] = _zero\n    assert isinstance(_zero, cls)\n    return _zero\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage","title":"frequenz.quantities.Voltage","text":"<p>               Bases: <code>Quantity</code></p> <p>A voltage quantity.</p> <p>Objects of this type are wrappers around <code>float</code> values and are immutable.</p> <p>The constructors accept a single <code>float</code> value, the <code>as_*()</code> methods return a <code>float</code> value, and each of the arithmetic operators supported by this type are actually implemented using floating-point arithmetic.</p> <p>So all considerations about floating-point arithmetic apply to this type as well.</p> Source code in <code>frequenz/quantities/_voltage.py</code> <pre><code>class Voltage(\n    Quantity,\n    metaclass=NoDefaultConstructible,\n    exponent_unit_map={0: \"V\", -3: \"mV\", 3: \"kV\"},\n):\n    \"\"\"A voltage quantity.\n\n    Objects of this type are wrappers around `float` values and are immutable.\n\n    The constructors accept a single `float` value, the `as_*()` methods return a\n    `float` value, and each of the arithmetic operators supported by this type are\n    actually implemented using floating-point arithmetic.\n\n    So all considerations about floating-point arithmetic apply to this type as well.\n    \"\"\"\n\n    @classmethod\n    def from_volts(cls, volts: float) -&gt; Self:\n        \"\"\"Initialize a new voltage quantity.\n\n        Args:\n            volts: The voltage in volts.\n\n        Returns:\n            A new voltage quantity.\n        \"\"\"\n        return cls._new(volts)\n\n    @classmethod\n    def from_millivolts(cls, millivolts: float) -&gt; Self:\n        \"\"\"Initialize a new voltage quantity.\n\n        Args:\n            millivolts: The voltage in millivolts.\n\n        Returns:\n            A new voltage quantity.\n        \"\"\"\n        return cls._new(millivolts, exponent=-3)\n\n    @classmethod\n    def from_kilovolts(cls, kilovolts: float) -&gt; Self:\n        \"\"\"Initialize a new voltage quantity.\n\n        Args:\n            kilovolts: The voltage in kilovolts.\n\n        Returns:\n            A new voltage quantity.\n        \"\"\"\n        return cls._new(kilovolts, exponent=3)\n\n    def as_volts(self) -&gt; float:\n        \"\"\"Return the voltage in volts.\n\n        Returns:\n            The voltage in volts.\n        \"\"\"\n        return self._base_value\n\n    def as_millivolts(self) -&gt; float:\n        \"\"\"Return the voltage in millivolts.\n\n        Returns:\n            The voltage in millivolts.\n        \"\"\"\n        return self._base_value * 1e3\n\n    def as_kilovolts(self) -&gt; float:\n        \"\"\"Return the voltage in kilovolts.\n\n        Returns:\n            The voltage in kilovolts.\n        \"\"\"\n        return self._base_value / 1e3\n\n    # See comment for Power.__mul__ for why we need the ignore here.\n    @overload  # type: ignore[override]\n    def __mul__(self, scalar: float, /) -&gt; Self:\n        \"\"\"Scale this voltage by a scalar.\n\n        Args:\n            scalar: The scalar by which to scale this voltage.\n\n        Returns:\n            The scaled voltage.\n        \"\"\"\n\n    @overload\n    def __mul__(self, percent: Percentage, /) -&gt; Self:\n        \"\"\"Scale this voltage by a percentage.\n\n        Args:\n            percent: The percentage by which to scale this voltage.\n\n        Returns:\n            The scaled voltage.\n        \"\"\"\n\n    @overload\n    def __mul__(self, other: Current, /) -&gt; Power:\n        \"\"\"Multiply the voltage by the current to get the power.\n\n        Args:\n            other: The current to multiply the voltage with.\n\n        Returns:\n            The calculated power.\n        \"\"\"\n\n    def __mul__(self, other: float | Percentage | Current, /) -&gt; Self | Power:\n        \"\"\"Return a voltage or power from multiplying this voltage by the given value.\n\n        Args:\n            other: The scalar, percentage or current to multiply by.\n\n        Returns:\n            The calculated voltage or power.\n        \"\"\"\n        from ._current import Current  # pylint: disable=import-outside-toplevel\n        from ._percentage import Percentage  # pylint: disable=import-outside-toplevel\n        from ._power import Power  # pylint: disable=import-outside-toplevel\n\n        match other:\n            case float() | Percentage():\n                return super().__mul__(other)\n            case Current():\n                return Power._new(self._base_value * other._base_value)\n            case _:\n                return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage.base_unit","title":"base_unit  <code>property</code>","text":"<pre><code>base_unit: str | None\n</code></pre> <p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage.base_value","title":"base_value  <code>property</code>","text":"<pre><code>base_value: float\n</code></pre> <p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage-functions","title":"Functions","text":""},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> <p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __abs__(self) -&gt; Self:\n    \"\"\"Return the absolute value of this quantity.\n\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\n    absolute = type(self).__new__(type(self))\n    absolute._base_value = abs(self._base_value)\n    return absolute\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage.__add__","title":"__add__","text":"<pre><code>__add__(other: Self) -&gt; Self\n</code></pre> <p>Return the sum of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n    \"\"\"Return the sum of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    summe = type(self).__new__(type(self))\n    summe._base_value = self._base_value + other._base_value\n    return summe\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether this quantity is equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Return whether this quantity is equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    # The above check ensures that both quantities are the exact same type, because\n    # `isinstance` returns true for subclasses and superclasses.  But the above check\n    # doesn't help mypy identify the type of other,  so the below line is necessary.\n    assert isinstance(other, self.__class__)\n    return self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage.__format__","title":"__format__","text":"<pre><code>__format__(__format_spec: str) -&gt; str\n</code></pre> <p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.quantities import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n    \"\"\"Return a formatted string representation of this quantity.\n\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n\n    Example:\n        ```python\n        from frequenz.quantities import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n\n    Args:\n        __format_spec: The format specifier.\n\n    Returns:\n        A string representation of this quantity.\n\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\n    keep_trailing_zeros = False\n    if __format_spec != \"\":\n        fspec_parts = __format_spec.split(\".\")\n        if (\n            len(fspec_parts) != 2\n            or fspec_parts[0] not in (\"\", \"0\")\n            or not fspec_parts[1].isdigit()\n        ):\n            raise ValueError(\n                \"Invalid format specifier. Must be empty or `[0].{precision}`\"\n            )\n        if fspec_parts[0] == \"0\":\n            keep_trailing_zeros = True\n        precision = int(fspec_parts[1])\n    else:\n        precision = 3\n    if not self._exponent_unit_map:\n        return f\"{self._base_value:.{precision}f}\"\n\n    if math.isinf(self._base_value) or math.isnan(self._base_value):\n        return f\"{self._base_value} {self._exponent_unit_map[0]}\"\n\n    if abs_value := abs(self._base_value):\n        precision_pow = 10 ** (precision)\n        # Prevent numbers like 999.999999 being rendered as 1000 V\n        # instead of 1 kV.\n        # This could happen because the str formatting function does\n        # rounding as well.\n        # This is an imperfect solution that works for _most_ cases.\n        # isclose parameters were chosen according to the observed cases\n        if math.isclose(abs_value, precision_pow, abs_tol=1e-4, rel_tol=0.01):\n            # If the value is close to the precision, round it\n            exponent = math.ceil(math.log10(precision_pow))\n        else:\n            exponent = math.floor(math.log10(abs_value))\n    else:\n        exponent = 0\n\n    unit_place = exponent - exponent % 3\n    if unit_place &lt; min(self._exponent_unit_map):\n        unit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\n        unit_place = min(self._exponent_unit_map)\n    elif unit_place &gt; max(self._exponent_unit_map):\n        unit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\n        unit_place = max(self._exponent_unit_map)\n    else:\n        unit = self._exponent_unit_map[unit_place]\n\n    value_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\n\n    if value_str in (\"-0\", \"0\"):\n        stripped = value_str\n    else:\n        stripped = value_str.rstrip(\"0\").rstrip(\".\")\n\n    if not keep_trailing_zeros:\n        value_str = stripped\n    unit_str = unit if stripped not in (\"-0\", \"0\") else self._exponent_unit_map[0]\n    return f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than or equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage.__init__","title":"__init__","text":"<pre><code>__init__(value: float, exponent: int = 0) -&gt; None\n</code></pre> <p>Initialize a new quantity.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n    \"\"\"Initialize a new quantity.\n\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\n    self._base_value = value * 10.0**exponent\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(\n    exponent_unit_map: dict[int, str]\n) -&gt; None\n</code></pre> <p>Initialize a new subclass of Quantity.</p> PARAMETER DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n    \"\"\"Initialize a new subclass of Quantity.\n\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n\n    Raises:\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\n    if 0 not in exponent_unit_map:\n        raise ValueError(\"Expected a base unit for the type (for exponent 0)\")\n    cls._exponent_unit_map = exponent_unit_map\n    super().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage.__le__","title":"__le__","text":"<pre><code>__le__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than or equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage.__mod__","title":"__mod__","text":"<pre><code>__mod__(other: Self) -&gt; Self\n</code></pre> <p>Return the remainder of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The remainder of this quantity and another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __mod__(self, other: Self) -&gt; Self:\n    \"\"\"Return the remainder of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The remainder of this quantity and another.\n    \"\"\"\n    return self._new(self._base_value % other._base_value)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage.__mul__","title":"__mul__","text":"<pre><code>__mul__(\n    other: float | Percentage | Current,\n) -&gt; Self | Power\n</code></pre> <p>Return a voltage or power from multiplying this voltage by the given value.</p> PARAMETER DESCRIPTION <code>other</code> <p>The scalar, percentage or current to multiply by.</p> <p> TYPE: <code>float | Percentage | Current</code> </p> RETURNS DESCRIPTION <code>Self | Power</code> <p>The calculated voltage or power.</p> Source code in <code>frequenz/quantities/_voltage.py</code> <pre><code>def __mul__(self, other: float | Percentage | Current, /) -&gt; Self | Power:\n    \"\"\"Return a voltage or power from multiplying this voltage by the given value.\n\n    Args:\n        other: The scalar, percentage or current to multiply by.\n\n    Returns:\n        The calculated voltage or power.\n    \"\"\"\n    from ._current import Current  # pylint: disable=import-outside-toplevel\n    from ._percentage import Percentage  # pylint: disable=import-outside-toplevel\n    from ._power import Power  # pylint: disable=import-outside-toplevel\n\n    match other:\n        case float() | Percentage():\n            return super().__mul__(other)\n        case Current():\n            return Power._new(self._base_value * other._base_value)\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> <p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __neg__(self) -&gt; Self:\n    \"\"\"Return the negation of this quantity.\n\n    Returns:\n        The negation of this quantity.\n    \"\"\"\n    negation = type(self).__new__(type(self))\n    negation._base_value = -self._base_value\n    return negation\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage.__pos__","title":"__pos__","text":"<pre><code>__pos__() -&gt; Self\n</code></pre> <p>Return this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>This quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __pos__(self) -&gt; Self:\n    \"\"\"Return this quantity.\n\n    Returns:\n        This quantity.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a representation of this quantity.\n\n    Returns:\n        A representation of this quantity.\n    \"\"\"\n    return f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage.__round__","title":"__round__","text":"<pre><code>__round__(ndigits: int | None = None) -&gt; Self\n</code></pre> <p>Round this quantity to the given number of digits.</p> PARAMETER DESCRIPTION <code>ndigits</code> <p>The number of digits to round to.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The rounded quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __round__(self, ndigits: int | None = None) -&gt; Self:\n    \"\"\"Round this quantity to the given number of digits.\n\n    Args:\n        ndigits: The number of digits to round to.\n\n    Returns:\n        The rounded quantity.\n    \"\"\"\n    return self._new(round(self._base_value, ndigits))\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this quantity.\n\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\n    return self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Self) -&gt; Self\n</code></pre> <p>Return the difference of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n    \"\"\"Return the difference of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    difference = type(self).__new__(type(self))\n    difference._base_value = self._base_value - other._base_value\n    return difference\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(value: float | Self) -&gt; Self | float\n</code></pre> <p>Divide this quantity by a scalar or another quantity.</p> PARAMETER DESCRIPTION <code>value</code> <p>The scalar or quantity to divide this quantity by.</p> <p> TYPE: <code>float | Self</code> </p> RETURNS DESCRIPTION <code>Self | float</code> <p>The divided quantity or the ratio of this quantity to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def __truediv__(self, value: float | Self, /) -&gt; Self | float:\n    \"\"\"Divide this quantity by a scalar or another quantity.\n\n    Args:\n        value: The scalar or quantity to divide this quantity by.\n\n    Returns:\n        The divided quantity or the ratio of this quantity to another.\n    \"\"\"\n    match value:\n        case float():\n            return type(self)._new(self._base_value / value)\n        case Quantity() if type(value) is type(self):\n            return self._base_value / value._base_value\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage.as_kilovolts","title":"as_kilovolts","text":"<pre><code>as_kilovolts() -&gt; float\n</code></pre> <p>Return the voltage in kilovolts.</p> RETURNS DESCRIPTION <code>float</code> <p>The voltage in kilovolts.</p> Source code in <code>frequenz/quantities/_voltage.py</code> <pre><code>def as_kilovolts(self) -&gt; float:\n    \"\"\"Return the voltage in kilovolts.\n\n    Returns:\n        The voltage in kilovolts.\n    \"\"\"\n    return self._base_value / 1e3\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage.as_millivolts","title":"as_millivolts","text":"<pre><code>as_millivolts() -&gt; float\n</code></pre> <p>Return the voltage in millivolts.</p> RETURNS DESCRIPTION <code>float</code> <p>The voltage in millivolts.</p> Source code in <code>frequenz/quantities/_voltage.py</code> <pre><code>def as_millivolts(self) -&gt; float:\n    \"\"\"Return the voltage in millivolts.\n\n    Returns:\n        The voltage in millivolts.\n    \"\"\"\n    return self._base_value * 1e3\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage.as_volts","title":"as_volts","text":"<pre><code>as_volts() -&gt; float\n</code></pre> <p>Return the voltage in volts.</p> RETURNS DESCRIPTION <code>float</code> <p>The voltage in volts.</p> Source code in <code>frequenz/quantities/_voltage.py</code> <pre><code>def as_volts(self) -&gt; float:\n    \"\"\"Return the voltage in volts.\n\n    Returns:\n        The voltage in volts.\n    \"\"\"\n    return self._base_value\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage.from_kilovolts","title":"from_kilovolts  <code>classmethod</code>","text":"<pre><code>from_kilovolts(kilovolts: float) -&gt; Self\n</code></pre> <p>Initialize a new voltage quantity.</p> PARAMETER DESCRIPTION <code>kilovolts</code> <p>The voltage in kilovolts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new voltage quantity.</p> Source code in <code>frequenz/quantities/_voltage.py</code> <pre><code>@classmethod\ndef from_kilovolts(cls, kilovolts: float) -&gt; Self:\n    \"\"\"Initialize a new voltage quantity.\n\n    Args:\n        kilovolts: The voltage in kilovolts.\n\n    Returns:\n        A new voltage quantity.\n    \"\"\"\n    return cls._new(kilovolts, exponent=3)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage.from_millivolts","title":"from_millivolts  <code>classmethod</code>","text":"<pre><code>from_millivolts(millivolts: float) -&gt; Self\n</code></pre> <p>Initialize a new voltage quantity.</p> PARAMETER DESCRIPTION <code>millivolts</code> <p>The voltage in millivolts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new voltage quantity.</p> Source code in <code>frequenz/quantities/_voltage.py</code> <pre><code>@classmethod\ndef from_millivolts(cls, millivolts: float) -&gt; Self:\n    \"\"\"Initialize a new voltage quantity.\n\n    Args:\n        millivolts: The voltage in millivolts.\n\n    Returns:\n        A new voltage quantity.\n    \"\"\"\n    return cls._new(millivolts, exponent=-3)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(string: str) -&gt; Self\n</code></pre> <p>Return a quantity from a string representation.</p> PARAMETER DESCRIPTION <code>string</code> <p>The string representation of the quantity.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity object with the value given in the string.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the string does not match the expected format.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>@classmethod\ndef from_string(cls, string: str) -&gt; Self:\n    \"\"\"Return a quantity from a string representation.\n\n    Args:\n        string: The string representation of the quantity.\n\n    Returns:\n        A quantity object with the value given in the string.\n\n    Raises:\n        ValueError: If the string does not match the expected format.\n\n    \"\"\"\n    split_string = string.split(\" \")\n\n    if len(split_string) != 2:\n        raise ValueError(\n            f\"Expected a string of the form 'value unit', got {string}\"\n        )\n\n    assert cls._exponent_unit_map is not None\n    exp_map = cls._exponent_unit_map\n\n    for exponent, unit in exp_map.items():\n        if unit == split_string[1]:\n            instance = cls.__new__(cls)\n            try:\n                instance._base_value = float(split_string[0]) * 10**exponent\n            except ValueError as error:\n                raise ValueError(f\"Failed to parse string '{string}'.\") from error\n\n            return instance\n\n    raise ValueError(f\"Unknown unit {split_string[1]}\")\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage.from_volts","title":"from_volts  <code>classmethod</code>","text":"<pre><code>from_volts(volts: float) -&gt; Self\n</code></pre> <p>Initialize a new voltage quantity.</p> PARAMETER DESCRIPTION <code>volts</code> <p>The voltage in volts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new voltage quantity.</p> Source code in <code>frequenz/quantities/_voltage.py</code> <pre><code>@classmethod\ndef from_volts(cls, volts: float) -&gt; Self:\n    \"\"\"Initialize a new voltage quantity.\n\n    Args:\n        volts: The voltage in volts.\n\n    Returns:\n        A new voltage quantity.\n    \"\"\"\n    return cls._new(volts)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage.isclose","title":"isclose","text":"<pre><code>isclose(\n    other: Self,\n    rel_tol: float = 1e-09,\n    abs_tol: float = 0.0,\n) -&gt; bool\n</code></pre> <p>Return whether this quantity is close to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n    \"\"\"Return whether this quantity is close to another.\n\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\n    return math.isclose(\n        self._base_value,\n        other._base_value,  # pylint: disable=protected-access\n        rel_tol=rel_tol,\n        abs_tol=abs_tol,\n    )\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage.isinf","title":"isinf","text":"<pre><code>isinf() -&gt; bool\n</code></pre> <p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def isinf(self) -&gt; bool:\n    \"\"\"Return whether this quantity is infinite.\n\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\n    return math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage.isnan","title":"isnan","text":"<pre><code>isnan() -&gt; bool\n</code></pre> <p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>def isnan(self) -&gt; bool:\n    \"\"\"Return whether this quantity is NaN.\n\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\n    return math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/quantities/#frequenz.quantities.Voltage.zero","title":"zero  <code>classmethod</code>","text":"<pre><code>zero() -&gt; Self\n</code></pre> <p>Return a quantity with value 0.0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.0.</p> Source code in <code>frequenz/quantities/_quantity.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n    \"\"\"Return a quantity with value 0.0.\n\n    Returns:\n        A quantity with value 0.0.\n    \"\"\"\n    _zero = cls._zero_cache.get(cls, None)\n    if _zero is None:\n        _zero = cls.__new__(cls)\n        _zero._base_value = 0.0\n        cls._zero_cache[cls] = _zero\n    assert isinstance(_zero, cls)\n    return _zero\n</code></pre>"}]}